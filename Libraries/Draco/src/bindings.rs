/* automatically generated by rust-bindgen 0.70.1 */

#![allow(clippy::missing_safety_doc)]
#![allow(clippy::too_many_arguments)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(improper_ctypes)]
pub type ValueType = std::os::raw::c_uint;

#[doc = "  @class basic_string basic_string.h <string>\n  @brief  Managing sequences of characters and character-like objects.\n\n  @ingroup strings\n  @ingroup sequences\n  @headerfile string\n  @since C++98\n\n  @tparam _CharT  Type of character\n  @tparam _Traits  Traits for character type, defaults to\n                   char_traits<_CharT>.\n  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.\n\n  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n  <a href=\"tables.html#66\">reversible container</a>, and a\n  <a href=\"tables.html#67\">sequence</a>.  Of the\n  <a href=\"tables.html#68\">optional sequence requirements</a>, only\n  @c push_back, @c at, and @c %array access are supported."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct basic_string {
    pub _address: u8,
}
pub type basic_string__Char_alloc_type = u8;
#[doc = " @brief  Uniform interface to C++98 and C++11 allocators.\n @ingroup allocators"]
pub type basic_string__Alloc_traits = u8;
#[doc = " Types:"]
pub type basic_string_traits_type = u8;
pub type basic_string_value_type = u8;
pub type basic_string_allocator_type = u8;
pub type basic_string_size_type = u8;
pub type basic_string_difference_type = u8;
pub type basic_string_reference = u8;
pub type basic_string_const_reference = u8;
pub type basic_string_pointer = u8;
pub type basic_string_const_pointer = u8;
#[doc = " This iterator adapter is @a normal in the sense that it does not\n change the semantics of any of the operators of its iterator\n parameter.  Its primary purpose is to convert an iterator that is\n not a class, e.g. a pointer, into an iterator that is a class.\n The _Container parameter exists solely so that different containers\n using this template can instantiate different types, even if the\n _Iterator parameter is the same."]
pub type basic_string_iterator = u8;
#[doc = " This iterator adapter is @a normal in the sense that it does not\n change the semantics of any of the operators of its iterator\n parameter.  Its primary purpose is to convert an iterator that is\n not a class, e.g. a pointer, into an iterator that is a class.\n The _Container parameter exists solely so that different containers\n using this template can instantiate different types, even if the\n _Iterator parameter is the same."]
pub type basic_string_const_iterator = u8;
#[doc = " 24.4.1 Reverse iterators\n**\n*  Bidirectional and random access iterators have corresponding reverse\n*  %iterator adaptors that iterate through the data structure in the\n*  opposite direction.  They have the same signatures as the corresponding\n*  iterators.  The fundamental relation between a reverse %iterator and its\n*  corresponding %iterator @c i is established by the identity:\n*  @code\n*      &*(reverse_iterator(i)) == &*(i - 1)\n*  @endcode\n*\n*  <em>This mapping is dictated by the fact that while there is always a\n*  pointer past the end of an array, there might not be a valid pointer\n*  before the beginning of an array.</em> [24.4.1]/1,2\n*\n*  Reverse iterators can be tricky and surprising at first.  Their\n*  semantics make sense, however, and the trickiness is a side effect of\n*  the requirement that the iterators must be safe.\n*/"]
pub type basic_string_const_reverse_iterator = u8;
#[doc = " 24.4.1 Reverse iterators\n**\n*  Bidirectional and random access iterators have corresponding reverse\n*  %iterator adaptors that iterate through the data structure in the\n*  opposite direction.  They have the same signatures as the corresponding\n*  iterators.  The fundamental relation between a reverse %iterator and its\n*  corresponding %iterator @c i is established by the identity:\n*  @code\n*      &*(reverse_iterator(i)) == &*(i - 1)\n*  @endcode\n*\n*  <em>This mapping is dictated by the fact that while there is always a\n*  pointer past the end of an array, there might not be a valid pointer\n*  before the beginning of an array.</em> [24.4.1]/1,2\n*\n*  Reverse iterators can be tricky and surprising at first.  Their\n*  semantics make sense, however, and the trickiness is a side effect of\n*  the requirement that the iterators must be safe.\n*/"]
pub type basic_string_reverse_iterator = u8;
#[doc = " This iterator adapter is @a normal in the sense that it does not\n change the semantics of any of the operators of its iterator\n parameter.  Its primary purpose is to convert an iterator that is\n not a class, e.g. a pointer, into an iterator that is a class.\n The _Container parameter exists solely so that different containers\n using this template can instantiate different types, even if the\n _Iterator parameter is the same."]
pub type basic_string___const_iterator = u8;
#[doc = " A helper type for avoiding boiler-plate."]
pub type basic_string___sv_type = u8;
pub type basic_string__If_sv = u8;
#[doc = " Wraps a string_view by explicit conversion and thus\n allows to add an internal constructor that does not\n participate in overload resolution when a string_view\n is provided."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct basic_string___sv_wrapper {
    pub _address: u8,
}
#[doc = " Use empty-base optimization: http://www.cantrip.org/emptyopt.html"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct basic_string__Alloc_hider {
    pub _address: u8,
}
pub const basic_string__S_local_capacity: basic_string__bindgen_ty_1 = 0;
pub type basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union basic_string__bindgen_ty_2 {
    pub _bindgen_opaque_blob: u64,
}
impl Default for basic_string__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  @brief Struct holding two objects of arbitrary type.\n\n  @tparam _T1  Type of first object.\n  @tparam _T2  Type of second object.\n\n  <https://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>\n\n @headerfile utility"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pair {
    pub _address: u8,
}
pub type pair_first_type = u8;
pub type pair_second_type = u8;
#[doc = " Shortcut for constraining the templates that don't take pairs.\n @cond undocumented"]
pub type pair__PCCP = u8;
#[doc = " Shortcut for constraining the templates that take pairs.\n @cond undocumented"]
pub type pair__PCCFP = u8;
#[doc = " A type which can be constructed from literal zero, but not nullptr"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pair___zero_as_null_pointer_constant {
    pub _address: u8,
}
pub type array_value_type = u8;
pub type array_pointer = u8;
pub type array_const_pointer = u8;
pub type array_reference = u8;
pub type array_const_reference = u8;
pub type array_iterator = u8;
pub type array_const_iterator = u8;
pub type array_size_type = u64;
pub type array_difference_type = u64;
#[doc = " 24.4.1 Reverse iterators\n**\n*  Bidirectional and random access iterators have corresponding reverse\n*  %iterator adaptors that iterate through the data structure in the\n*  opposite direction.  They have the same signatures as the corresponding\n*  iterators.  The fundamental relation between a reverse %iterator and its\n*  corresponding %iterator @c i is established by the identity:\n*  @code\n*      &*(reverse_iterator(i)) == &*(i - 1)\n*  @endcode\n*\n*  <em>This mapping is dictated by the fact that while there is always a\n*  pointer past the end of an array, there might not be a valid pointer\n*  before the beginning of an array.</em> [24.4.1]/1,2\n*\n*  Reverse iterators can be tricky and surprising at first.  Their\n*  semantics make sense, however, and the trickiness is a side effect of\n*  the requirement that the iterators must be safe.\n*/"]
pub type array_reverse_iterator = u8;
#[doc = " 24.4.1 Reverse iterators\n**\n*  Bidirectional and random access iterators have corresponding reverse\n*  %iterator adaptors that iterate through the data structure in the\n*  opposite direction.  They have the same signatures as the corresponding\n*  iterators.  The fundamental relation between a reverse %iterator and its\n*  corresponding %iterator @c i is established by the identity:\n*  @code\n*      &*(reverse_iterator(i)) == &*(i - 1)\n*  @endcode\n*\n*  <em>This mapping is dictated by the fact that while there is always a\n*  pointer past the end of an array, there might not be a valid pointer\n*  before the beginning of an array.</em> [24.4.1]/1,2\n*\n*  Reverse iterators can be tricky and surprising at first.  Their\n*  semantics make sense, however, and the trickiness is a side effect of\n*  the requirement that the iterators must be safe.\n*/"]
pub type array_const_reverse_iterator = u8;
#[doc = " A string of @c char"]
pub type string = [u64; 4usize];
#[doc = " Base class for @c char output streams."]
pub type ostream = [u64; 34usize];
#[doc = " Helpers for streambuf iterators (either istream or ostream).\n NB: avoid including <iosfwd>, relatively large."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct char_traits {
    pub _address: u8,
}
#[doc = " @brief  The @a standard allocator, as per C++03 [20.4.1].\n\n  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator\n  for further details.\n\n  @tparam  _Tp  Type of allocated object.\n\n  @headerfile memory"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct allocator {
    pub _address: u8,
}
pub type allocator_value_type = u8;
pub type allocator_size_type = u64;
pub type allocator_difference_type = u64;
#[doc = " These were removed for C++20."]
pub type allocator_pointer = u8;
pub type allocator_const_pointer = u8;
pub type allocator_reference = u8;
pub type allocator_const_reference = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct allocator_rebind {
    pub _address: u8,
}
#[doc = " @brief  The @a standard allocator, as per C++03 [20.4.1].\n\n  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator\n  for further details.\n\n  @tparam  _Tp  Type of allocated object.\n\n  @headerfile memory"]
pub type allocator_rebind_other = u8;
#[doc = " _GLIBCXX_RESOLVE_LIB_DEFECTS\n 2103. std::allocator propagate_on_container_move_assignment"]
pub type allocator_propagate_on_container_move_assignment = u8;
#[doc = " integral_constant"]
pub type allocator_is_always_equal = u8;
#[doc = " One of the @link comparison_functors comparison functors@endlink."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct less {
    pub _address: u8,
}
#[doc = "  @brief A standard container which offers fixed time access to\n  individual elements in any order.\n\n  @ingroup sequences\n  @headerfile vector\n  @since C++98\n\n  @tparam _Tp  Type of element.\n  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.\n\n  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n  <a href=\"tables.html#66\">reversible container</a>, and a\n  <a href=\"tables.html#67\">sequence</a>, including the\n  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n  %exception of @c push_front and @c pop_front.\n\n  In some terminology a %vector can be described as a dynamic\n  C-style array, it offers fast and efficient access to individual\n  elements in any order and saves the user from worrying about\n  memory and size allocation.  Subscripting ( @c [] ) access is\n  also provided as with C-style arrays."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vector {
    pub _address: u8,
}
#[doc = " See bits/stl_deque.h's _Deque_base for an explanation."]
pub type vector__Base = u8;
pub type vector__Tp_alloc_type = u8;
#[doc = " @brief  Uniform interface to C++98 and C++11 allocators.\n @ingroup allocators"]
pub type vector__Alloc_traits = u8;
pub type vector_value_type = u8;
pub type vector_pointer = u8;
pub type vector_const_pointer = u8;
pub type vector_reference = u8;
pub type vector_const_reference = u8;
#[doc = " This iterator adapter is @a normal in the sense that it does not\n change the semantics of any of the operators of its iterator\n parameter.  Its primary purpose is to convert an iterator that is\n not a class, e.g. a pointer, into an iterator that is a class.\n The _Container parameter exists solely so that different containers\n using this template can instantiate different types, even if the\n _Iterator parameter is the same."]
pub type vector_iterator = u8;
#[doc = " This iterator adapter is @a normal in the sense that it does not\n change the semantics of any of the operators of its iterator\n parameter.  Its primary purpose is to convert an iterator that is\n not a class, e.g. a pointer, into an iterator that is a class.\n The _Container parameter exists solely so that different containers\n using this template can instantiate different types, even if the\n _Iterator parameter is the same."]
pub type vector_const_iterator = u8;
#[doc = " 24.4.1 Reverse iterators\n**\n*  Bidirectional and random access iterators have corresponding reverse\n*  %iterator adaptors that iterate through the data structure in the\n*  opposite direction.  They have the same signatures as the corresponding\n*  iterators.  The fundamental relation between a reverse %iterator and its\n*  corresponding %iterator @c i is established by the identity:\n*  @code\n*      &*(reverse_iterator(i)) == &*(i - 1)\n*  @endcode\n*\n*  <em>This mapping is dictated by the fact that while there is always a\n*  pointer past the end of an array, there might not be a valid pointer\n*  before the beginning of an array.</em> [24.4.1]/1,2\n*\n*  Reverse iterators can be tricky and surprising at first.  Their\n*  semantics make sense, however, and the trickiness is a side effect of\n*  the requirement that the iterators must be safe.\n*/"]
pub type vector_const_reverse_iterator = u8;
#[doc = " 24.4.1 Reverse iterators\n**\n*  Bidirectional and random access iterators have corresponding reverse\n*  %iterator adaptors that iterate through the data structure in the\n*  opposite direction.  They have the same signatures as the corresponding\n*  iterators.  The fundamental relation between a reverse %iterator and its\n*  corresponding %iterator @c i is established by the identity:\n*  @code\n*      &*(reverse_iterator(i)) == &*(i - 1)\n*  @endcode\n*\n*  <em>This mapping is dictated by the fact that while there is always a\n*  pointer past the end of an array, there might not be a valid pointer\n*  before the beginning of an array.</em> [24.4.1]/1,2\n*\n*  Reverse iterators can be tricky and surprising at first.  Their\n*  semantics make sense, however, and the trickiness is a side effect of\n*  the requirement that the iterators must be safe.\n*/"]
pub type vector_reverse_iterator = u8;
pub type vector_size_type = u64;
pub type vector_difference_type = u64;
pub type vector_allocator_type = u8;
#[doc = " A value_type object constructed with _Alloc_traits::construct()\n and destroyed with _Alloc_traits::destroy()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vector__Temporary_value {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Copy, Clone)]
pub union vector__Temporary_value__Storage {
    pub _bindgen_opaque_blob: u8,
}
impl Default for vector__Temporary_value__Storage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Primary template of default_delete, used by unique_ptr for single objects\n\n @headerfile memory\n @since C++11"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct default_delete {
    pub _address: u8,
}
#[doc = " A move-only smart pointer that manages unique ownership of a resource.\n @headerfile memory\n @since C++11"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct unique_ptr {
    pub _address: u8,
}
pub type unique_ptr__DeleterConstraint = u8;
pub type unique_ptr_pointer = u8;
pub type unique_ptr_element_type = u8;
pub type unique_ptr_deleter_type = u8;
#[doc = " helper template for detecting a safe conversion from another\n unique_ptr"]
pub type unique_ptr___safe_conversion_up = u8;
#[doc = "  @brief A standard container made up of (key,value) pairs, which can be\n  retrieved based on a key, in logarithmic time.\n\n  @ingroup associative_containers\n  @headerfile map\n  @since C++98\n\n  @tparam _Key  Type of key objects.\n  @tparam  _Tp  Type of mapped objects.\n  @tparam _Compare  Comparison function object type, defaults to less<_Key>.\n  @tparam _Alloc  Allocator type, defaults to\n                  allocator<pair<const _Key, _Tp>.\n\n  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n  <a href=\"tables.html#66\">reversible container</a>, and an\n  <a href=\"tables.html#69\">associative container</a> (using unique keys).\n  For a @c map<Key,T> the key_type is Key, the mapped_type is T, and the\n  value_type is std::pair<const Key,T>.\n\n  Maps support bidirectional iterators.\n\n  The private tree data is declared exactly the same way for map and\n  multimap; the distinction is made entirely in how the tree functions are\n  called (*_unique versus *_equal, same as the standard)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct map {
    pub _address: u8,
}
pub type map_key_type = u8;
pub type map_mapped_type = u8;
#[doc = "  @brief Struct holding two objects of arbitrary type.\n\n  @tparam _T1  Type of first object.\n  @tparam _T2  Type of second object.\n\n  <https://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>\n\n @headerfile utility"]
pub type map_value_type = u8;
pub type map_key_compare = u8;
pub type map_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct map_value_compare {
    pub _address: u8,
}
#[doc = " This turns a red-black tree into a [multi]map."]
pub type map__Pair_alloc_type = u8;
pub type map__Rep_type = u8;
#[doc = " @brief  Uniform interface to C++98 and C++11 allocators.\n @ingroup allocators"]
pub type map__Alloc_traits = u8;
#[doc = " many of these are specified differently in ISO, but the following are\n \"functionally equivalent\""]
pub type map_pointer = u8;
pub type map_const_pointer = u8;
pub type map_reference = u8;
pub type map_const_reference = u8;
pub type map_iterator = u8;
pub type map_const_iterator = u8;
pub type map_size_type = u8;
pub type map_difference_type = u8;
pub type map_reverse_iterator = u8;
pub type map_const_reverse_iterator = u8;
pub type map_node_type = u8;
pub type map_insert_return_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexType<ValueTypeT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueTypeT>>,
    pub value_: ValueTypeT,
}
pub type IndexType_ThisIndexType<ValueTypeT> = IndexType<ValueTypeT>;
pub type IndexType_ValueType<ValueTypeT> = ValueTypeT;
impl<ValueTypeT> Default for IndexType<ValueTypeT> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Index of an attribute value entry stored in a GeometryAttribute."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AttributeValueIndex_tag_type_ {
    pub _address: u8,
}
#[doc = " Index of an attribute value entry stored in a GeometryAttribute."]
pub type AttributeValueIndex = IndexType<u32>;
#[doc = " Index of a point in a PointCloud."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PointIndex_tag_type_ {
    pub _address: u8,
}
#[doc = " Index of a point in a PointCloud."]
pub type PointIndex = IndexType<u32>;
#[doc = " Corner index that identifies a corner in a Mesh or CornerTable."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CornerIndex_tag_type_ {
    pub _address: u8,
}
#[doc = " Corner index that identifies a corner in a Mesh or CornerTable."]
pub type CornerIndex = IndexType<u32>;
#[doc = " Face index for Mesh and CornerTable."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FaceIndex_tag_type_ {
    pub _address: u8,
}
#[doc = " Face index for Mesh and CornerTable."]
pub type FaceIndex = IndexType<u32>;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_INVALID: DataType = 0;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_INT8: DataType = 1;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_UINT8: DataType = 2;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_INT16: DataType = 3;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_UINT16: DataType = 4;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_INT32: DataType = 5;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_UINT32: DataType = 6;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_INT64: DataType = 7;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_UINT64: DataType = 8;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_FLOAT32: DataType = 9;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_FLOAT64: DataType = 10;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_BOOL: DataType = 11;
#[doc = " Not a legal value for DataType. Used to indicate a field has not been set."]
pub const DataType_DT_TYPES_COUNT: DataType = 12;
pub type DataType = ::std::os::raw::c_uint;
#[doc = " Buffer descriptor servers as a unique identifier of a buffer."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DataBufferDescriptor {
    #[doc = " Id of the data buffer."]
    pub buffer_id: i64,
    #[doc = " The number of times the buffer content was updated."]
    pub buffer_update_count: i64,
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco20DataBufferDescriptorC1Ev"]
    pub fn DataBufferDescriptor_DataBufferDescriptor(this: *mut DataBufferDescriptor);
}
impl DataBufferDescriptor {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        DataBufferDescriptor_DataBufferDescriptor(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Class used for storing raw buffer data."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct DataBuffer {
    pub data_: [u64; 3usize],
    #[doc = " Counter incremented by Update() calls."]
    pub descriptor_: DataBufferDescriptor,
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBuffer6UpdateEPKvl"]
    pub fn DataBuffer_Update(
        this: *mut DataBuffer,
        data: *const ::std::os::raw::c_void,
        size: i64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBuffer6UpdateEPKvll"]
    pub fn DataBuffer_Update1(
        this: *mut DataBuffer,
        data: *const ::std::os::raw::c_void,
        size: i64,
        offset: i64,
    ) -> bool;
}
extern "C" {
    #[doc = " Reallocate the buffer storage to a new size keeping the data unchanged."]
    #[link_name = "\u{1}_ZN5draco10DataBuffer6ResizeEl"]
    pub fn DataBuffer_Resize(this: *mut DataBuffer, new_size: i64);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBuffer17WriteDataToStreamERSo"]
    pub fn DataBuffer_WriteDataToStream(this: *mut DataBuffer, stream: *mut ostream);
}
extern "C" {
    #[doc = " Reads data from the buffer. Potentially unsafe, called needs to ensure\n the accessed memory is valid."]
    #[link_name = "\u{1}_ZNK5draco10DataBuffer4ReadElPvm"]
    pub fn DataBuffer_Read(
        this: *const DataBuffer,
        byte_pos: i64,
        out_data: *mut ::std::os::raw::c_void,
        data_size: usize,
    );
}
extern "C" {
    #[doc = " Writes data to the buffer. Unsafe, caller must ensure the accessed memory\n is valid."]
    #[link_name = "\u{1}_ZN5draco10DataBuffer5WriteElPKvm"]
    pub fn DataBuffer_Write(
        this: *mut DataBuffer,
        byte_pos: i64,
        in_data: *const ::std::os::raw::c_void,
        data_size: usize,
    );
}
extern "C" {
    #[doc = " Copies data from another buffer to this buffer."]
    #[link_name = "\u{1}_ZN5draco10DataBuffer4CopyElPKS0_ll"]
    pub fn DataBuffer_Copy(
        this: *mut DataBuffer,
        dst_offset: i64,
        src_buf: *const DataBuffer,
        src_offset: i64,
        size: i64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBuffer16set_update_countEl"]
    pub fn DataBuffer_set_update_count(this: *mut DataBuffer, buffer_update_count: i64);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10DataBuffer12update_countEv"]
    pub fn DataBuffer_update_count(this: *const DataBuffer) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10DataBuffer9data_sizeEv"]
    pub fn DataBuffer_data_size(this: *const DataBuffer) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10DataBuffer4dataEv"]
    pub fn DataBuffer_data(this: *const DataBuffer) -> *const u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBuffer4dataEv"]
    pub fn DataBuffer_data1(this: *mut DataBuffer) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10DataBuffer9buffer_idEv"]
    pub fn DataBuffer_buffer_id(this: *const DataBuffer) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBuffer13set_buffer_idEl"]
    pub fn DataBuffer_set_buffer_id(this: *mut DataBuffer, buffer_id: i64);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBufferC1Ev"]
    pub fn DataBuffer_DataBuffer(this: *mut DataBuffer);
}
impl DataBuffer {
    #[inline]
    pub unsafe fn Update(&mut self, data: *const ::std::os::raw::c_void, size: i64) -> bool {
        DataBuffer_Update(self, data, size)
    }
    #[inline]
    pub unsafe fn Update1(
        &mut self,
        data: *const ::std::os::raw::c_void,
        size: i64,
        offset: i64,
    ) -> bool {
        DataBuffer_Update1(self, data, size, offset)
    }
    #[inline]
    pub unsafe fn Resize(&mut self, new_size: i64) {
        DataBuffer_Resize(self, new_size)
    }
    #[inline]
    pub unsafe fn WriteDataToStream(&mut self, stream: *mut ostream) {
        DataBuffer_WriteDataToStream(self, stream)
    }
    #[inline]
    pub unsafe fn Read(
        &self,
        byte_pos: i64,
        out_data: *mut ::std::os::raw::c_void,
        data_size: usize,
    ) {
        DataBuffer_Read(self, byte_pos, out_data, data_size)
    }
    #[inline]
    pub unsafe fn Write(
        &mut self,
        byte_pos: i64,
        in_data: *const ::std::os::raw::c_void,
        data_size: usize,
    ) {
        DataBuffer_Write(self, byte_pos, in_data, data_size)
    }
    #[inline]
    pub unsafe fn Copy(
        &mut self,
        dst_offset: i64,
        src_buf: *const DataBuffer,
        src_offset: i64,
        size: i64,
    ) {
        DataBuffer_Copy(self, dst_offset, src_buf, src_offset, size)
    }
    #[inline]
    pub unsafe fn set_update_count(&mut self, buffer_update_count: i64) {
        DataBuffer_set_update_count(self, buffer_update_count)
    }
    #[inline]
    pub unsafe fn update_count(&self) -> i64 {
        DataBuffer_update_count(self)
    }
    #[inline]
    pub unsafe fn data_size(&self) -> usize {
        DataBuffer_data_size(self)
    }
    #[inline]
    pub unsafe fn data(&self) -> *const u8 {
        DataBuffer_data(self)
    }
    #[inline]
    pub unsafe fn data1(&mut self) -> *mut u8 {
        DataBuffer_data1(self)
    }
    #[inline]
    pub unsafe fn buffer_id(&self) -> i64 {
        DataBuffer_buffer_id(self)
    }
    #[inline]
    pub unsafe fn set_buffer_id(&mut self, buffer_id: i64) {
        DataBuffer_set_buffer_id(self, buffer_id)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        DataBuffer_DataBuffer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " The class provides access to a specific attribute which is stored in a\n DataBuffer, such as normals or coordinates. However, the GeometryAttribute\n class does not own the buffer and the buffer itself may store other data\n unrelated to this attribute (such as data for other attributes in which case\n we can have multiple GeometryAttributes accessing one buffer). Typically,\n all attributes for a point (or corner, face) are stored in one block, which\n is advantageous in terms of memory access. The length of the entire block is\n given by the byte_stride, the position where the attribute starts is given by\n the byte_offset, the actual number of bytes that the attribute occupies is\n given by the data_type and the number of components."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeometryAttribute {
    pub buffer_: *mut DataBuffer,
    #[doc = " The buffer descriptor is stored at the time the buffer is attached to this\n attribute. The purpose is to detect if any changes happened to the buffer\n since the time it was attached."]
    pub buffer_descriptor_: DataBufferDescriptor,
    pub num_components_: u8,
    pub data_type_: DataType,
    pub normalized_: bool,
    pub byte_stride_: i64,
    pub byte_offset_: i64,
    pub attribute_type_: GeometryAttribute_Type,
    #[doc = " Unique id of this attribute. No two attributes could have the same unique\n id. It is used to identify each attribute, especially when there are\n multiple attribute of the same type in a point cloud."]
    pub unique_id_: u32,
}
pub const GeometryAttribute_Type_INVALID: GeometryAttribute_Type = -1;
#[doc = " Named attributes start here. The difference between named and generic\n attributes is that for named attributes we know their purpose and we\n can apply some special methods when dealing with them (e.g. during\n encoding)."]
pub const GeometryAttribute_Type_POSITION: GeometryAttribute_Type = 0;
#[doc = " Named attributes start here. The difference between named and generic\n attributes is that for named attributes we know their purpose and we\n can apply some special methods when dealing with them (e.g. during\n encoding)."]
pub const GeometryAttribute_Type_NORMAL: GeometryAttribute_Type = 1;
#[doc = " Named attributes start here. The difference between named and generic\n attributes is that for named attributes we know their purpose and we\n can apply some special methods when dealing with them (e.g. during\n encoding)."]
pub const GeometryAttribute_Type_COLOR: GeometryAttribute_Type = 2;
#[doc = " Named attributes start here. The difference between named and generic\n attributes is that for named attributes we know their purpose and we\n can apply some special methods when dealing with them (e.g. during\n encoding)."]
pub const GeometryAttribute_Type_TEX_COORD: GeometryAttribute_Type = 3;
#[doc = " A special id used to mark attributes that are not assigned to any known\n predefined use case. Such attributes are often used for a shader specific\n data."]
pub const GeometryAttribute_Type_GENERIC: GeometryAttribute_Type = 4;
#[doc = " Total number of different attribute types.\n Always keep behind all named attributes."]
pub const GeometryAttribute_Type_NAMED_ATTRIBUTES_COUNT: GeometryAttribute_Type = 5;
#[doc = " Supported attribute types."]
pub type GeometryAttribute_Type = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Initializes and enables the attribute."]
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute4InitENS0_4TypeEPNS_10DataBufferEhNS_8DataTypeEbll"]
    pub fn GeometryAttribute_Init(
        this: *mut GeometryAttribute,
        attribute_type: GeometryAttribute_Type,
        buffer: *mut DataBuffer,
        num_components: u8,
        data_type: DataType,
        normalized: bool,
        byte_stride: i64,
        byte_offset: i64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute7IsValidEv"]
    pub fn GeometryAttribute_IsValid(this: *const GeometryAttribute) -> bool;
}
extern "C" {
    #[doc = " Copies data from the source attribute to the this attribute.\n This attribute must have a valid buffer allocated otherwise the operation\n is going to fail and return false."]
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute8CopyFromERKS0_"]
    pub fn GeometryAttribute_CopyFrom(
        this: *mut GeometryAttribute,
        src_att: *const GeometryAttribute,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the byte position of the attribute entry in the data buffer."]
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute10GetBytePosENS_9IndexTypeIjNS_29AttributeValueIndex_tag_type_EEE"]
    pub fn GeometryAttribute_GetBytePos(
        this: *const GeometryAttribute,
        att_index: AttributeValueIndex,
    ) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute10GetAddressENS_9IndexTypeIjNS_29AttributeValueIndex_tag_type_EEE"]
    pub fn GeometryAttribute_GetAddress(
        this: *const GeometryAttribute,
        att_index: AttributeValueIndex,
    ) -> *const u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute10GetAddressENS_9IndexTypeIjNS_29AttributeValueIndex_tag_type_EEE"]
    pub fn GeometryAttribute_GetAddress1(
        this: *mut GeometryAttribute,
        att_index: AttributeValueIndex,
    ) -> *mut u8;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute14IsAddressValidEPKh"]
    pub fn GeometryAttribute_IsAddressValid(
        this: *const GeometryAttribute,
        address: *const u8,
    ) -> bool;
}
extern "C" {
    #[doc = " Fills out_data with the raw value of the requested attribute entry.\n out_data must be at least byte_stride_ long."]
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute8GetValueENS_9IndexTypeIjNS_29AttributeValueIndex_tag_type_EEEPv"]
    pub fn GeometryAttribute_GetValue(
        this: *const GeometryAttribute,
        att_index: AttributeValueIndex,
        out_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Sets a value of an attribute entry. The input value must be allocated to\n cover all components of a single attribute entry."]
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute17SetAttributeValueENS_9IndexTypeIjNS_29AttributeValueIndex_tag_type_EEEPKv"]
    pub fn GeometryAttribute_SetAttributeValue(
        this: *mut GeometryAttribute,
        entry_index: AttributeValueIndex,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Utility function. Returns |attribute_type| as std::string."]
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute12TypeToStringB5cxx11ENS0_4TypeE"]
    pub fn GeometryAttribute_TypeToString(attribute_type: GeometryAttribute_Type) -> string;
}
extern "C" {
    #[doc = " Returns the type of the attribute indicating the nature of the attribute."]
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute14attribute_typeEv"]
    pub fn GeometryAttribute_attribute_type(
        this: *const GeometryAttribute,
    ) -> GeometryAttribute_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute18set_attribute_typeENS0_4TypeE"]
    pub fn GeometryAttribute_set_attribute_type(
        this: *mut GeometryAttribute,
        type_: GeometryAttribute_Type,
    );
}
extern "C" {
    #[doc = " Returns the data type that is stored in the attribute."]
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute9data_typeEv"]
    pub fn GeometryAttribute_data_type(this: *const GeometryAttribute) -> DataType;
}
extern "C" {
    #[doc = " Returns the number of components that are stored for each entry.\n For position attribute this is usually three (x,y,z),\n while texture coordinates have two components (u,v)."]
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute14num_componentsEv"]
    pub fn GeometryAttribute_num_components(this: *const GeometryAttribute) -> u8;
}
extern "C" {
    #[doc = " Indicates whether the data type should be normalized before interpretation,\n that is, it should be divided by the max value of the data type."]
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute10normalizedEv"]
    pub fn GeometryAttribute_normalized(this: *const GeometryAttribute) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute14set_normalizedEb"]
    pub fn GeometryAttribute_set_normalized(this: *mut GeometryAttribute, normalized: bool);
}
extern "C" {
    #[doc = " The buffer storing the entire data of the attribute."]
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute6bufferEv"]
    pub fn GeometryAttribute_buffer(this: *const GeometryAttribute) -> *const DataBuffer;
}
extern "C" {
    #[doc = " Returns the number of bytes between two attribute entries, this is, at\n least size of the data types times number of components."]
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute11byte_strideEv"]
    pub fn GeometryAttribute_byte_stride(this: *const GeometryAttribute) -> i64;
}
extern "C" {
    #[doc = " The offset where the attribute starts within the block of size byte_stride."]
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute11byte_offsetEv"]
    pub fn GeometryAttribute_byte_offset(this: *const GeometryAttribute) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute15set_byte_offsetEl"]
    pub fn GeometryAttribute_set_byte_offset(this: *mut GeometryAttribute, byte_offset: i64);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute17buffer_descriptorEv"]
    pub fn GeometryAttribute_buffer_descriptor(
        this: *const GeometryAttribute,
    ) -> DataBufferDescriptor;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17GeometryAttribute9unique_idEv"]
    pub fn GeometryAttribute_unique_id(this: *const GeometryAttribute) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute13set_unique_idEj"]
    pub fn GeometryAttribute_set_unique_id(this: *mut GeometryAttribute, id: u32);
}
extern "C" {
    #[doc = " Sets a new internal storage for the attribute."]
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute11ResetBufferEPNS_10DataBufferEll"]
    pub fn GeometryAttribute_ResetBuffer(
        this: *mut GeometryAttribute,
        buffer: *mut DataBuffer,
        byte_stride: i64,
        byte_offset: i64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17GeometryAttributeC1Ev"]
    pub fn GeometryAttribute_GeometryAttribute(this: *mut GeometryAttribute);
}
impl Default for GeometryAttribute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl GeometryAttribute {
    #[inline]
    pub unsafe fn Init(
        &mut self,
        attribute_type: GeometryAttribute_Type,
        buffer: *mut DataBuffer,
        num_components: u8,
        data_type: DataType,
        normalized: bool,
        byte_stride: i64,
        byte_offset: i64,
    ) {
        GeometryAttribute_Init(
            self,
            attribute_type,
            buffer,
            num_components,
            data_type,
            normalized,
            byte_stride,
            byte_offset,
        )
    }
    #[inline]
    pub unsafe fn IsValid(&self) -> bool {
        GeometryAttribute_IsValid(self)
    }
    #[inline]
    pub unsafe fn CopyFrom(&mut self, src_att: *const GeometryAttribute) -> bool {
        GeometryAttribute_CopyFrom(self, src_att)
    }
    #[inline]
    pub unsafe fn GetBytePos(&self, att_index: AttributeValueIndex) -> i64 {
        GeometryAttribute_GetBytePos(self, att_index)
    }
    #[inline]
    pub unsafe fn GetAddress(&self, att_index: AttributeValueIndex) -> *const u8 {
        GeometryAttribute_GetAddress(self, att_index)
    }
    #[inline]
    pub unsafe fn GetAddress1(&mut self, att_index: AttributeValueIndex) -> *mut u8 {
        GeometryAttribute_GetAddress1(self, att_index)
    }
    #[inline]
    pub unsafe fn IsAddressValid(&self, address: *const u8) -> bool {
        GeometryAttribute_IsAddressValid(self, address)
    }
    #[inline]
    pub unsafe fn GetValue(
        &self,
        att_index: AttributeValueIndex,
        out_data: *mut ::std::os::raw::c_void,
    ) {
        GeometryAttribute_GetValue(self, att_index, out_data)
    }
    #[inline]
    pub unsafe fn SetAttributeValue(
        &mut self,
        entry_index: AttributeValueIndex,
        value: *const ::std::os::raw::c_void,
    ) {
        GeometryAttribute_SetAttributeValue(self, entry_index, value)
    }
    #[inline]
    pub unsafe fn TypeToString(attribute_type: GeometryAttribute_Type) -> string {
        GeometryAttribute_TypeToString(attribute_type)
    }
    #[inline]
    pub unsafe fn attribute_type(&self) -> GeometryAttribute_Type {
        GeometryAttribute_attribute_type(self)
    }
    #[inline]
    pub unsafe fn set_attribute_type(&mut self, type_: GeometryAttribute_Type) {
        GeometryAttribute_set_attribute_type(self, type_)
    }
    #[inline]
    pub unsafe fn data_type(&self) -> DataType {
        GeometryAttribute_data_type(self)
    }
    #[inline]
    pub unsafe fn num_components(&self) -> u8 {
        GeometryAttribute_num_components(self)
    }
    #[inline]
    pub unsafe fn normalized(&self) -> bool {
        GeometryAttribute_normalized(self)
    }
    #[inline]
    pub unsafe fn set_normalized(&mut self, normalized: bool) {
        GeometryAttribute_set_normalized(self, normalized)
    }
    #[inline]
    pub unsafe fn buffer(&self) -> *const DataBuffer {
        GeometryAttribute_buffer(self)
    }
    #[inline]
    pub unsafe fn byte_stride(&self) -> i64 {
        GeometryAttribute_byte_stride(self)
    }
    #[inline]
    pub unsafe fn byte_offset(&self) -> i64 {
        GeometryAttribute_byte_offset(self)
    }
    #[inline]
    pub unsafe fn set_byte_offset(&mut self, byte_offset: i64) {
        GeometryAttribute_set_byte_offset(self, byte_offset)
    }
    #[inline]
    pub unsafe fn buffer_descriptor(&self) -> DataBufferDescriptor {
        GeometryAttribute_buffer_descriptor(self)
    }
    #[inline]
    pub unsafe fn unique_id(&self) -> u32 {
        GeometryAttribute_unique_id(self)
    }
    #[inline]
    pub unsafe fn set_unique_id(&mut self, id: u32) {
        GeometryAttribute_set_unique_id(self, id)
    }
    #[inline]
    pub unsafe fn ResetBuffer(
        &mut self,
        buffer: *mut DataBuffer,
        byte_stride: i64,
        byte_offset: i64,
    ) {
        GeometryAttribute_ResetBuffer(self, buffer, byte_stride, byte_offset)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        GeometryAttribute_GeometryAttribute(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
pub const AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM: AttributeTransformType = -1;
pub const AttributeTransformType_ATTRIBUTE_NO_TRANSFORM: AttributeTransformType = 0;
pub const AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM: AttributeTransformType = 1;
pub const AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM: AttributeTransformType = 2;
#[doc = " List of all currently supported attribute transforms."]
pub type AttributeTransformType = ::std::os::raw::c_int;
#[doc = " Class for holding parameter values for an attribute transform of a\n PointAttribute. This can be for example quantization data for an attribute\n that holds quantized values. This class provides only a basic storage for\n attribute transform parameters and it should be accessed only through wrapper\n classes for a specific transform (e.g. AttributeQuantizationTransform)."]
#[repr(C)]
#[derive(Debug)]
pub struct AttributeTransformData {
    pub transform_type_: AttributeTransformType,
    pub buffer_: DataBuffer,
}
extern "C" {
    #[doc = " Returns the type of the attribute transform that is described by the class."]
    #[link_name = "\u{1}_ZNK5draco22AttributeTransformData14transform_typeEv"]
    pub fn AttributeTransformData_transform_type(
        this: *const AttributeTransformData,
    ) -> AttributeTransformType;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco22AttributeTransformData18set_transform_typeENS_22AttributeTransformTypeE"]
    pub fn AttributeTransformData_set_transform_type(
        this: *mut AttributeTransformData,
        type_: AttributeTransformType,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco22AttributeTransformDataC1Ev"]
    pub fn AttributeTransformData_AttributeTransformData(this: *mut AttributeTransformData);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco22AttributeTransformDataC1ERKS0_"]
    pub fn AttributeTransformData_AttributeTransformData1(
        this: *mut AttributeTransformData,
        data: *const AttributeTransformData,
    );
}
impl Default for AttributeTransformData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl AttributeTransformData {
    #[inline]
    pub unsafe fn transform_type(&self) -> AttributeTransformType {
        AttributeTransformData_transform_type(self)
    }
    #[inline]
    pub unsafe fn set_transform_type(&mut self, type_: AttributeTransformType) {
        AttributeTransformData_set_transform_type(self, type_)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AttributeTransformData_AttributeTransformData(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(data: *const AttributeTransformData) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AttributeTransformData_AttributeTransformData1(__bindgen_tmp.as_mut_ptr(), data);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " A wrapper around the standard std::vector that supports indexing of the\n vector entries using the strongly typed indices as defined in\n draco_index_type.h.\n TODO(ostava): Make the interface more complete. It's currently missing some\n features."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct IndexTypeVector {
    pub vector_: u8,
}
pub type IndexTypeVector_const_reference = u8;
pub type IndexTypeVector_reference = u8;
pub type IndexTypeVector_iterator = u8;
pub type IndexTypeVector_const_iterator = u8;
#[doc = " Class for storing point specific data about each attribute. In general,\n multiple points stored in a point cloud can share the same attribute value\n and this class provides the necessary mapping between point ids and attribute\n value ids."]
#[repr(C)]
pub struct PointAttribute {
    pub _base: GeometryAttribute,
    #[doc = " Data storage for attribute values. GeometryAttribute itself doesn't own its\n buffer so we need to allocate it here."]
    pub attribute_buffer_: u64,
    #[doc = " Mapping between point ids and attribute value ids."]
    pub indices_map_: IndexTypeVector,
    pub num_unique_entries_: ValueType,
    #[doc = " Flag when the mapping between point ids and attribute values is identity."]
    pub identity_mapping_: bool,
    #[doc = " If an attribute contains transformed data (e.g. quantized), we can specify\n the attribute transform here and use it to transform the attribute back to\n its original format."]
    pub attribute_transform_data_: u64,
}
extern "C" {
    #[doc = " Initializes a point attribute. By default the attribute will be set to\n identity mapping between point indices and attribute values. To set custom\n mapping use SetExplicitMapping() function."]
    #[link_name = "\u{1}_ZN5draco14PointAttribute4InitENS_17GeometryAttribute4TypeEaNS_8DataTypeEbm"]
    pub fn PointAttribute_Init(
        this: *mut PointAttribute,
        attribute_type: GeometryAttribute_Type,
        num_components: i8,
        data_type: DataType,
        normalized: bool,
        num_attribute_values: usize,
    );
}
extern "C" {
    #[doc = " Copies attribute data from the provided |src_att| attribute."]
    #[link_name = "\u{1}_ZN5draco14PointAttribute8CopyFromERKS0_"]
    pub fn PointAttribute_CopyFrom(this: *mut PointAttribute, src_att: *const PointAttribute);
}
extern "C" {
    #[doc = " Prepares the attribute storage for the specified number of entries."]
    #[link_name = "\u{1}_ZN5draco14PointAttribute5ResetEm"]
    pub fn PointAttribute_Reset(this: *mut PointAttribute, num_attribute_values: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco14PointAttribute4sizeEv"]
    pub fn PointAttribute_size(this: *const PointAttribute) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco14PointAttribute12mapped_indexENS_9IndexTypeIjNS_20PointIndex_tag_type_EEE"]
    pub fn PointAttribute_mapped_index(
        this: *const PointAttribute,
        point_index: PointIndex,
    ) -> AttributeValueIndex;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco14PointAttribute6bufferEv"]
    pub fn PointAttribute_buffer(this: *const PointAttribute) -> *mut DataBuffer;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco14PointAttribute19is_mapping_identityEv"]
    pub fn PointAttribute_is_mapping_identity(this: *const PointAttribute) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco14PointAttribute16indices_map_sizeEv"]
    pub fn PointAttribute_indices_map_size(this: *const PointAttribute) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco14PointAttribute23GetAddressOfMappedIndexENS_9IndexTypeIjNS_20PointIndex_tag_type_EEE"]
    pub fn PointAttribute_GetAddressOfMappedIndex(
        this: *const PointAttribute,
        point_index: PointIndex,
    ) -> *const u8;
}
extern "C" {
    #[doc = " Sets the new number of unique attribute entries for the attribute. The\n function resizes the attribute storage to hold |num_attribute_values|\n entries.\n All previous entries with AttributeValueIndex < |num_attribute_values|\n are preserved. Caller needs to ensure that the PointAttribute is still\n valid after the resizing operation (that is, each point is mapped to a\n valid attribute value)."]
    #[link_name = "\u{1}_ZN5draco14PointAttribute6ResizeEm"]
    pub fn PointAttribute_Resize(this: *mut PointAttribute, new_num_unique_entries: usize);
}
extern "C" {
    #[doc = " Functions for setting the type of mapping between point indices and\n attribute entry ids.\n This function sets the mapping to implicit, where point indices are equal\n to attribute entry indices."]
    #[link_name = "\u{1}_ZN5draco14PointAttribute18SetIdentityMappingEv"]
    pub fn PointAttribute_SetIdentityMapping(this: *mut PointAttribute);
}
extern "C" {
    #[doc = " This function sets the mapping to be explicitly using the indices_map_\n array that needs to be initialized by the caller."]
    #[link_name = "\u{1}_ZN5draco14PointAttribute18SetExplicitMappingEm"]
    pub fn PointAttribute_SetExplicitMapping(this: *mut PointAttribute, num_points: usize);
}
extern "C" {
    #[doc = " Set an explicit map entry for a specific point index."]
    #[link_name = "\u{1}_ZN5draco14PointAttribute16SetPointMapEntryENS_9IndexTypeIjNS_20PointIndex_tag_type_EEENS1_IjNS_29AttributeValueIndex_tag_type_EEE"]
    pub fn PointAttribute_SetPointMapEntry(
        this: *mut PointAttribute,
        point_index: PointIndex,
        entry_index: AttributeValueIndex,
    );
}
extern "C" {
    #[doc = " Same as GeometryAttribute::GetValue(), but using point id as the input.\n Mapping to attribute value index is performed automatically."]
    #[link_name = "\u{1}_ZNK5draco14PointAttribute14GetMappedValueENS_9IndexTypeIjNS_20PointIndex_tag_type_EEEPv"]
    pub fn PointAttribute_GetMappedValue(
        this: *const PointAttribute,
        point_index: PointIndex,
        out_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Deduplicate |in_att| values into |this| attribute. |in_att| can be equal\n to |this|.\n Returns -1 if the deduplication failed."]
    #[link_name = "\u{1}_ZN5draco14PointAttribute17DeduplicateValuesERKNS_17GeometryAttributeE"]
    pub fn PointAttribute_DeduplicateValues(
        this: *mut PointAttribute,
        in_att: *const GeometryAttribute,
    ) -> ValueType;
}
extern "C" {
    #[doc = " Same as above but the values read from |in_att| are sampled with the\n provided offset |in_att_offset|."]
    #[link_name = "\u{1}_ZN5draco14PointAttribute17DeduplicateValuesERKNS_17GeometryAttributeENS_9IndexTypeIjNS_29AttributeValueIndex_tag_type_EEE"]
    pub fn PointAttribute_DeduplicateValues1(
        this: *mut PointAttribute,
        in_att: *const GeometryAttribute,
        in_att_offset: AttributeValueIndex,
    ) -> ValueType;
}
extern "C" {
    #[doc = " Set attribute transform data for the attribute. The data is used to store\n the type and parameters of the transform that is applied on the attribute\n data (optional)."]
    #[link_name = "\u{1}_ZN5draco14PointAttribute25SetAttributeTransformDataESt10unique_ptrINS_22AttributeTransformDataESt14default_deleteIS2_EE"]
    pub fn PointAttribute_SetAttributeTransformData(this: *mut PointAttribute, transform_data: u64);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco14PointAttribute25GetAttributeTransformDataEv"]
    pub fn PointAttribute_GetAttributeTransformData(
        this: *const PointAttribute,
    ) -> *const AttributeTransformData;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco14PointAttributeC1Ev"]
    pub fn PointAttribute_PointAttribute(this: *mut PointAttribute);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco14PointAttributeC1ERKNS_17GeometryAttributeE"]
    pub fn PointAttribute_PointAttribute1(this: *mut PointAttribute, att: *const GeometryAttribute);
}
extern "C" {
    #[doc = " Make sure the move constructor is defined (needed for better performance\n when new attributes are added to PointCloud)."]
    #[link_name = "\u{1}_ZN5draco14PointAttributeC1EOS0_"]
    pub fn PointAttribute_PointAttribute2(
        this: *mut PointAttribute,
        attribute: *mut PointAttribute,
    );
}
impl Default for PointAttribute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl PointAttribute {
    #[inline]
    pub unsafe fn Init(
        &mut self,
        attribute_type: GeometryAttribute_Type,
        num_components: i8,
        data_type: DataType,
        normalized: bool,
        num_attribute_values: usize,
    ) {
        PointAttribute_Init(
            self,
            attribute_type,
            num_components,
            data_type,
            normalized,
            num_attribute_values,
        )
    }
    #[inline]
    pub unsafe fn CopyFrom(&mut self, src_att: *const PointAttribute) {
        PointAttribute_CopyFrom(self, src_att)
    }
    #[inline]
    pub unsafe fn Reset(&mut self, num_attribute_values: usize) -> bool {
        PointAttribute_Reset(self, num_attribute_values)
    }
    #[inline]
    pub unsafe fn size(&self) -> usize {
        PointAttribute_size(self)
    }
    #[inline]
    pub unsafe fn mapped_index(&self, point_index: PointIndex) -> AttributeValueIndex {
        PointAttribute_mapped_index(self, point_index)
    }
    #[inline]
    pub unsafe fn buffer(&self) -> *mut DataBuffer {
        PointAttribute_buffer(self)
    }
    #[inline]
    pub unsafe fn is_mapping_identity(&self) -> bool {
        PointAttribute_is_mapping_identity(self)
    }
    #[inline]
    pub unsafe fn indices_map_size(&self) -> usize {
        PointAttribute_indices_map_size(self)
    }
    #[inline]
    pub unsafe fn GetAddressOfMappedIndex(&self, point_index: PointIndex) -> *const u8 {
        PointAttribute_GetAddressOfMappedIndex(self, point_index)
    }
    #[inline]
    pub unsafe fn Resize(&mut self, new_num_unique_entries: usize) {
        PointAttribute_Resize(self, new_num_unique_entries)
    }
    #[inline]
    pub unsafe fn SetIdentityMapping(&mut self) {
        PointAttribute_SetIdentityMapping(self)
    }
    #[inline]
    pub unsafe fn SetExplicitMapping(&mut self, num_points: usize) {
        PointAttribute_SetExplicitMapping(self, num_points)
    }
    #[inline]
    pub unsafe fn SetPointMapEntry(
        &mut self,
        point_index: PointIndex,
        entry_index: AttributeValueIndex,
    ) {
        PointAttribute_SetPointMapEntry(self, point_index, entry_index)
    }
    #[inline]
    pub unsafe fn GetMappedValue(
        &self,
        point_index: PointIndex,
        out_data: *mut ::std::os::raw::c_void,
    ) {
        PointAttribute_GetMappedValue(self, point_index, out_data)
    }
    #[inline]
    pub unsafe fn DeduplicateValues(&mut self, in_att: *const GeometryAttribute) -> ValueType {
        PointAttribute_DeduplicateValues(self, in_att)
    }
    #[inline]
    pub unsafe fn DeduplicateValues1(
        &mut self,
        in_att: *const GeometryAttribute,
        in_att_offset: AttributeValueIndex,
    ) -> ValueType {
        PointAttribute_DeduplicateValues1(self, in_att, in_att_offset)
    }
    #[inline]
    pub unsafe fn SetAttributeTransformData(&mut self, transform_data: u64) {
        PointAttribute_SetAttributeTransformData(self, transform_data)
    }
    #[inline]
    pub unsafe fn GetAttributeTransformData(&self) -> *const AttributeTransformData {
        PointAttribute_GetAttributeTransformData(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        PointAttribute_PointAttribute(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(att: *const GeometryAttribute) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        PointAttribute_PointAttribute1(__bindgen_tmp.as_mut_ptr(), att);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(attribute: *mut PointAttribute) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        PointAttribute_PointAttribute2(__bindgen_tmp.as_mut_ptr(), attribute);
        __bindgen_tmp.assume_init()
    }
}
pub const EncodedGeometryType_INVALID_GEOMETRY_TYPE: EncodedGeometryType = -1;
pub const EncodedGeometryType_POINT_CLOUD: EncodedGeometryType = 0;
pub const EncodedGeometryType_TRIANGULAR_MESH: EncodedGeometryType = 1;
pub const EncodedGeometryType_NUM_ENCODED_GEOMETRY_TYPES: EncodedGeometryType = 2;
#[doc = " Currently, we support point cloud and triangular mesh encoding.\n TODO(draco-eng) Convert enum to enum class (safety, not performance)."]
pub type EncodedGeometryType = ::std::os::raw::c_int;
pub const PointCloudEncodingMethod_POINT_CLOUD_SEQUENTIAL_ENCODING: PointCloudEncodingMethod = 0;
pub const PointCloudEncodingMethod_POINT_CLOUD_KD_TREE_ENCODING: PointCloudEncodingMethod = 1;
#[doc = " List of encoding methods for point clouds."]
pub type PointCloudEncodingMethod = ::std::os::raw::c_uint;
#[doc = " Draco header V1"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DracoHeader {
    pub draco_string: [i8; 5usize],
    pub version_major: u8,
    pub version_minor: u8,
    pub encoder_type: u8,
    pub encoder_method: u8,
    pub flags: u16,
}
#[doc = " Class for storing generic options as a <name, value> pair in a string map.\n The API provides helper methods for directly storing values of various types\n such as ints and bools. One named option should be set with only a single\n data type."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct Options {
    #[doc = " All entries are internally stored as strings and converted to the desired\n return type based on the used Get* method."]
    pub options_: [u64; 6usize],
}
extern "C" {
    #[doc = " Merges |other_options| on top of the existing options of this instance\n replacing all entries that are present in both options instances."]
    #[link_name = "\u{1}_ZN5draco7Options15MergeAndReplaceERKS0_"]
    pub fn Options_MergeAndReplace(this: *mut Options, other_options: *const Options);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Options6SetIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn Options_SetInt(this: *mut Options, name: *const string, val: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Options8SetFloatERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEf"]
    pub fn Options_SetFloat(this: *mut Options, name: *const string, val: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Options7SetBoolERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb"]
    pub fn Options_SetBool(this: *mut Options, name: *const string, val: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Options9SetStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn Options_SetString(this: *mut Options, name: *const string, val: *const string);
}
extern "C" {
    #[doc = " Getters will return a default value if the entry is not found. The default\n value can be specified in the overloaded version of each function."]
    #[link_name = "\u{1}_ZNK5draco7Options6GetIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Options_GetInt(this: *const Options, name: *const string) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options6GetIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn Options_GetInt1(
        this: *const Options,
        name: *const string,
        default_val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options8GetFloatERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Options_GetFloat(this: *const Options, name: *const string) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options8GetFloatERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEf"]
    pub fn Options_GetFloat1(this: *const Options, name: *const string, default_val: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options7GetBoolERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Options_GetBool(this: *const Options, name: *const string) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options7GetBoolERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb"]
    pub fn Options_GetBool1(this: *const Options, name: *const string, default_val: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options9GetStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Options_GetString(this: *const Options, name: *const string) -> string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options9GetStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn Options_GetString1(
        this: *const Options,
        name: *const string,
        default_val: *const string,
    ) -> string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options11IsOptionSetERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Options_IsOptionSet(this: *const Options, name: *const string) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7OptionsC1Ev"]
    pub fn Options_Options(this: *mut Options);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7OptionsD1Ev"]
    pub fn Options_Options_destructor(this: *mut Options);
}
impl Options {
    #[inline]
    pub unsafe fn MergeAndReplace(&mut self, other_options: *const Options) {
        Options_MergeAndReplace(self, other_options)
    }
    #[inline]
    pub unsafe fn SetInt(&mut self, name: *const string, val: ::std::os::raw::c_int) {
        Options_SetInt(self, name, val)
    }
    #[inline]
    pub unsafe fn SetFloat(&mut self, name: *const string, val: f32) {
        Options_SetFloat(self, name, val)
    }
    #[inline]
    pub unsafe fn SetBool(&mut self, name: *const string, val: bool) {
        Options_SetBool(self, name, val)
    }
    #[inline]
    pub unsafe fn SetString(&mut self, name: *const string, val: *const string) {
        Options_SetString(self, name, val)
    }
    #[inline]
    pub unsafe fn GetInt(&self, name: *const string) -> ::std::os::raw::c_int {
        Options_GetInt(self, name)
    }
    #[inline]
    pub unsafe fn GetInt1(
        &self,
        name: *const string,
        default_val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Options_GetInt1(self, name, default_val)
    }
    #[inline]
    pub unsafe fn GetFloat(&self, name: *const string) -> f32 {
        Options_GetFloat(self, name)
    }
    #[inline]
    pub unsafe fn GetFloat1(&self, name: *const string, default_val: f32) -> f32 {
        Options_GetFloat1(self, name, default_val)
    }
    #[inline]
    pub unsafe fn GetBool(&self, name: *const string) -> bool {
        Options_GetBool(self, name)
    }
    #[inline]
    pub unsafe fn GetBool1(&self, name: *const string, default_val: bool) -> bool {
        Options_GetBool1(self, name, default_val)
    }
    #[inline]
    pub unsafe fn GetString(&self, name: *const string) -> string {
        Options_GetString(self, name)
    }
    #[inline]
    pub unsafe fn GetString1(&self, name: *const string, default_val: *const string) -> string {
        Options_GetString1(self, name, default_val)
    }
    #[inline]
    pub unsafe fn IsOptionSet(&self, name: *const string) -> bool {
        Options_IsOptionSet(self, name)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Options_Options(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        Options_Options_destructor(self)
    }
}
#[doc = " Base option class used to control encoding and decoding. The geometry coding\n can be controlled through the following options:\n   1. Global options - Options specific to overall geometry or options common\n                       for all attributes\n   2. Per attribute options - Options specific to a given attribute.\n                              Each attribute is identified by the template\n                              argument AttributeKeyT that can be for example\n                              the attribute type or the attribute id.\n\n Example:\n\n   DracoOptions<AttributeKey> options;\n\n   // Set an option common for all attributes.\n   options.SetGlobalInt(\"some_option_name\", 2);\n\n   // Geometry with two attributes.\n   AttributeKey att_key0 = in_key0;\n   AttributeKey att_key1 = in_key1;\n\n   options.SetAttributeInt(att_key0, \"some_option_name\", 3);\n\n   options.GetAttributeInt(att_key0, \"some_option_name\");  // Returns 3\n   options.GetAttributeInt(att_key1, \"some_option_name\");  // Returns 2\n   options.GetGlobalInt(\"some_option_name\");               // Returns 2\n"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct DracoOptions {
    pub global_options_: Options,
    #[doc = " Storage for options related to geometry attributes."]
    pub attribute_options_: u8,
}
pub type DracoOptions_AttributeKey<AttributeKeyT> = AttributeKeyT;
#[doc = " EncoderOptions allow users to specify so called feature options that are used\n to inform the encoder which encoding features can be used (i.e. which\n features are going to be available to the decoder)."]
#[repr(C)]
#[derive(Debug)]
pub struct EncoderOptionsBase {
    pub _base: DracoOptions,
    #[doc = " List of supported/unsupported features that can be used by the encoder."]
    pub feature_options_: Options,
}
impl Default for EncoderOptionsBase {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Encoder options where attributes are identified by their attribute id.\n Used to set options that are specific to a given geometry."]
pub type EncoderOptions = EncoderOptionsBase;
#[doc = " Class encapsulating a return status of an operation with an optional error\n message. Intended to be used as a return type for functions instead of bool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Status {
    pub code_: Status_Code,
    pub error_msg_: string,
}
pub const Status_Code_OK: Status_Code = 0;
#[doc = " Used for general errors."]
pub const Status_Code_DRACO_ERROR: Status_Code = -1;
#[doc = " Error when handling input or output stream."]
pub const Status_Code_IO_ERROR: Status_Code = -2;
#[doc = " Invalid parameter passed to a function."]
pub const Status_Code_INVALID_PARAMETER: Status_Code = -3;
#[doc = " Input not compatible with the current version."]
pub const Status_Code_UNSUPPORTED_VERSION: Status_Code = -4;
#[doc = " Input was created with an unknown version of\n the library."]
pub const Status_Code_UNKNOWN_VERSION: Status_Code = -5;
#[doc = " Input contains feature that is not supported."]
pub const Status_Code_UNSUPPORTED_FEATURE: Status_Code = -6;
pub type Status_Code = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "\u{1}_ZNK5draco6Status4codeEv"]
    pub fn Status_code(this: *const Status) -> Status_Code;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco6Status16error_msg_stringB5cxx11Ev"]
    pub fn Status_error_msg_string(this: *const Status) -> *const string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco6Status9error_msgEv"]
    pub fn Status_error_msg(this: *const Status) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco6Status11code_stringB5cxx11Ev"]
    pub fn Status_code_string(this: *const Status) -> string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco6Status21code_and_error_stringB5cxx11Ev"]
    pub fn Status_code_and_error_string(this: *const Status) -> string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco6Status2okEv"]
    pub fn Status_ok(this: *const Status) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco6StatusC1Ev"]
    pub fn Status_Status(this: *mut Status);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco6StatusC1ERKS0_"]
    pub fn Status_Status1(this: *mut Status, status: *const Status);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco6StatusC1EOS0_"]
    pub fn Status_Status2(this: *mut Status, status: *mut Status);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco6StatusC1ENS0_4CodeE"]
    pub fn Status_Status3(this: *mut Status, code: Status_Code);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco6StatusC1ENS0_4CodeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Status_Status4(this: *mut Status, code: Status_Code, error_msg: *const string);
}
impl Default for Status {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Status {
    #[inline]
    pub unsafe fn code(&self) -> Status_Code {
        Status_code(self)
    }
    #[inline]
    pub unsafe fn error_msg_string(&self) -> *const string {
        Status_error_msg_string(self)
    }
    #[inline]
    pub unsafe fn error_msg(&self) -> *const ::std::os::raw::c_char {
        Status_error_msg(self)
    }
    #[inline]
    pub unsafe fn code_string(&self) -> string {
        Status_code_string(self)
    }
    #[inline]
    pub unsafe fn code_and_error_string(&self) -> string {
        Status_code_and_error_string(self)
    }
    #[inline]
    pub unsafe fn ok(&self) -> bool {
        Status_ok(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Status_Status(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(status: *const Status) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Status_Status1(__bindgen_tmp.as_mut_ptr(), status);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(status: *mut Status) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Status_Status2(__bindgen_tmp.as_mut_ptr(), status);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(code: Status_Code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Status_Status3(__bindgen_tmp.as_mut_ptr(), code);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(code: Status_Code, error_msg: *const string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Status_Status4(__bindgen_tmp.as_mut_ptr(), code, error_msg);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct EncoderBase__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Base class for our geometry encoder classes. |EncoderOptionsT| specifies\n options class used by the encoder. Please, see encode.h and expert_encode.h\n for more details and method descriptions."]
#[repr(C)]
#[derive(Debug)]
pub struct EncoderBase<EncoderOptionsT> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<EncoderOptionsT>>,
    pub vtable_: *const EncoderBase__bindgen_vtable,
    pub options_: EncoderOptionsT,
    pub num_encoded_points_: usize,
    pub num_encoded_faces_: usize,
}
pub type EncoderBase_OptionsType<EncoderOptionsT> = EncoderOptionsT;
impl<EncoderOptionsT> Default for EncoderBase<EncoderOptionsT> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Class representing a buffer that can be used for either for byte-aligned\n encoding of arbitrary data structures or for encoding of variable-length\n bit data."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct EncoderBuffer {
    #[doc = " All data is stored in this vector."]
    pub buffer_: [u64; 3usize],
    #[doc = " Bit encoder is used when encoding variable-length bit data.\n TODO(ostava): Currently encoder needs to be recreated each time\n StartBitEncoding method is called. This is not necessary if BitEncoder\n supported reset function which can easily added but let's leave that for\n later."]
    pub bit_encoder_: u64,
    #[doc = " The number of bytes reserved for bit encoder.\n Values > 0 indicate we are in the bit encoding mode."]
    pub bit_encoder_reserved_bytes_: i64,
    #[doc = " Flag used indicating that we need to store the length of the currently\n processed bit sequence."]
    pub encode_bit_sequence_size_: bool,
}
#[doc = " Internal helper class to encode bits to a bit buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EncoderBuffer_BitEncoder {
    pub bit_buffer_: *mut ::std::os::raw::c_char,
    pub bit_offset_: usize,
}
extern "C" {
    #[doc = " Write |nbits| of |data| into the bit buffer."]
    #[link_name = "\u{1}_ZN5draco13EncoderBuffer10BitEncoder7PutBitsEji"]
    pub fn EncoderBuffer_BitEncoder_PutBits(
        this: *mut EncoderBuffer_BitEncoder,
        data: u32,
        nbits: i32,
    );
}
extern "C" {
    #[doc = " Return number of bits encoded so far."]
    #[link_name = "\u{1}_ZNK5draco13EncoderBuffer10BitEncoder4BitsEv"]
    pub fn EncoderBuffer_BitEncoder_Bits(this: *const EncoderBuffer_BitEncoder) -> u64;
}
extern "C" {
    #[doc = " TODO(fgalligan): Remove this function once we know we do not need the\n old API anymore.\n This is a function of an old API, that currently does nothing."]
    #[link_name = "\u{1}_ZN5draco13EncoderBuffer10BitEncoder5FlushEi"]
    pub fn EncoderBuffer_BitEncoder_Flush(
        this: *mut EncoderBuffer_BitEncoder,
        arg1: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Return the number of bits required to store the given number"]
    #[link_name = "\u{1}_ZN5draco13EncoderBuffer10BitEncoder12BitsRequiredEj"]
    pub fn EncoderBuffer_BitEncoder_BitsRequired(x: u32) -> u32;
}
extern "C" {
    #[doc = " |data| is the buffer to write the bits into."]
    #[link_name = "\u{1}_ZN5draco13EncoderBuffer10BitEncoderC1EPc"]
    pub fn EncoderBuffer_BitEncoder_BitEncoder(
        this: *mut EncoderBuffer_BitEncoder,
        data: *mut ::std::os::raw::c_char,
    );
}
impl Default for EncoderBuffer_BitEncoder {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl EncoderBuffer_BitEncoder {
    #[inline]
    pub unsafe fn PutBits(&mut self, data: u32, nbits: i32) {
        EncoderBuffer_BitEncoder_PutBits(self, data, nbits)
    }
    #[inline]
    pub unsafe fn Bits(&self) -> u64 {
        EncoderBuffer_BitEncoder_Bits(self)
    }
    #[inline]
    pub unsafe fn Flush(&mut self, arg1: ::std::os::raw::c_int) {
        EncoderBuffer_BitEncoder_Flush(self, arg1)
    }
    #[inline]
    pub unsafe fn BitsRequired(x: u32) -> u32 {
        EncoderBuffer_BitEncoder_BitsRequired(x)
    }
    #[inline]
    pub unsafe fn new(data: *mut ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        EncoderBuffer_BitEncoder_BitEncoder(__bindgen_tmp.as_mut_ptr(), data);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13EncoderBuffer5ClearEv"]
    pub fn EncoderBuffer_Clear(this: *mut EncoderBuffer);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13EncoderBuffer6ResizeEl"]
    pub fn EncoderBuffer_Resize(this: *mut EncoderBuffer, nbytes: i64);
}
extern "C" {
    #[doc = " Start encoding a bit sequence. A maximum size of the sequence needs to\n be known upfront.\n If encode_size is true, the size of encoded bit sequence is stored before\n the sequence. Decoder can then use this size to skip over the bit sequence\n if needed.\n Returns false on error."]
    #[link_name = "\u{1}_ZN5draco13EncoderBuffer16StartBitEncodingElb"]
    pub fn EncoderBuffer_StartBitEncoding(
        this: *mut EncoderBuffer,
        required_bits: i64,
        encode_size: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " End the encoding of the bit sequence and return to the default byte-aligned\n encoding."]
    #[link_name = "\u{1}_ZN5draco13EncoderBuffer14EndBitEncodingEv"]
    pub fn EncoderBuffer_EndBitEncoding(this: *mut EncoderBuffer);
}
extern "C" {
    #[doc = " Encode up to 32 bits into the buffer. Can be called only in between\n StartBitEncoding and EndBitEncoding. Otherwise returns false."]
    #[link_name = "\u{1}_ZN5draco13EncoderBuffer28EncodeLeastSignificantBits32Eij"]
    pub fn EncoderBuffer_EncodeLeastSignificantBits32(
        this: *mut EncoderBuffer,
        nbits: ::std::os::raw::c_int,
        value: u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13EncoderBuffer6EncodeEPKvm"]
    pub fn EncoderBuffer_Encode(
        this: *mut EncoderBuffer,
        data: *const ::std::os::raw::c_void,
        data_size: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco13EncoderBuffer18bit_encoder_activeEv"]
    pub fn EncoderBuffer_bit_encoder_active(this: *const EncoderBuffer) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco13EncoderBuffer4dataEv"]
    pub fn EncoderBuffer_data(this: *const EncoderBuffer) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco13EncoderBuffer4sizeEv"]
    pub fn EncoderBuffer_size(this: *const EncoderBuffer) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13EncoderBuffer6bufferEv"]
    pub fn EncoderBuffer_buffer(this: *mut EncoderBuffer) -> *mut [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13EncoderBufferC1Ev"]
    pub fn EncoderBuffer_EncoderBuffer(this: *mut EncoderBuffer);
}
impl EncoderBuffer {
    #[inline]
    pub unsafe fn Clear(&mut self) {
        EncoderBuffer_Clear(self)
    }
    #[inline]
    pub unsafe fn Resize(&mut self, nbytes: i64) {
        EncoderBuffer_Resize(self, nbytes)
    }
    #[inline]
    pub unsafe fn StartBitEncoding(&mut self, required_bits: i64, encode_size: bool) -> bool {
        EncoderBuffer_StartBitEncoding(self, required_bits, encode_size)
    }
    #[inline]
    pub unsafe fn EndBitEncoding(&mut self) {
        EncoderBuffer_EndBitEncoding(self)
    }
    #[inline]
    pub unsafe fn EncodeLeastSignificantBits32(
        &mut self,
        nbits: ::std::os::raw::c_int,
        value: u32,
    ) -> bool {
        EncoderBuffer_EncodeLeastSignificantBits32(self, nbits, value)
    }
    #[inline]
    pub unsafe fn Encode(&mut self, data: *const ::std::os::raw::c_void, data_size: usize) -> bool {
        EncoderBuffer_Encode(self, data, data_size)
    }
    #[inline]
    pub unsafe fn bit_encoder_active(&self) -> bool {
        EncoderBuffer_bit_encoder_active(self)
    }
    #[inline]
    pub unsafe fn data(&self) -> *const ::std::os::raw::c_char {
        EncoderBuffer_data(self)
    }
    #[inline]
    pub unsafe fn size(&self) -> usize {
        EncoderBuffer_size(self)
    }
    #[inline]
    pub unsafe fn buffer(&mut self) -> *mut [u64; 3usize] {
        EncoderBuffer_buffer(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        EncoderBuffer_EncoderBuffer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
pub type VectorD_Scalar<ScalarT> = ScalarT;
#[doc = " D-dimensional vector class with basic operations."]
pub type VectorD_Self = u8;
#[doc = " TODO(b/199760123): Deprecate."]
pub type VectorD_CoefficientType<ScalarT> = ScalarT;
#[doc = " D-dimensional vector class with basic operations."]
pub type Vector3f = [u32; 3usize];
#[doc = " Class for computing the bounding box of points in 3D space."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BoundingBox {
    pub min_point_: Vector3f,
    pub max_point_: Vector3f,
}
extern "C" {
    #[doc = " Returns the minimum point of the bounding box."]
    #[link_name = "\u{1}_ZNK5draco11BoundingBox11GetMinPointEv"]
    pub fn BoundingBox_GetMinPoint(this: *const BoundingBox) -> *const Vector3f;
}
extern "C" {
    #[doc = " Returns the maximum point of the bounding box."]
    #[link_name = "\u{1}_ZNK5draco11BoundingBox11GetMaxPointEv"]
    pub fn BoundingBox_GetMaxPoint(this: *const BoundingBox) -> *const Vector3f;
}
extern "C" {
    #[doc = " Checks if the bounding box object was created with the default constructor\n then never updated. Internally, checks if the bounding box minimum and\n maximum points hold the largest positive and smallest negative values."]
    #[link_name = "\u{1}_ZNK5draco11BoundingBox7IsValidEv"]
    pub fn BoundingBox_IsValid(this: *const BoundingBox) -> bool;
}
extern "C" {
    #[doc = " Conditionally updates the bounding box with a given |new_point|."]
    #[link_name = "\u{1}_ZN5draco11BoundingBox6UpdateERKNS_7VectorDIfLi3EEE"]
    pub fn BoundingBox_Update(this: *mut BoundingBox, new_point: *const Vector3f);
}
extern "C" {
    #[doc = " Updates bounding box with minimum and maximum points of the |other|\n bounding box."]
    #[link_name = "\u{1}_ZN5draco11BoundingBox6UpdateERKS0_"]
    pub fn BoundingBox_Update1(this: *mut BoundingBox, other: *const BoundingBox);
}
extern "C" {
    #[doc = " Returns the size of the bounding box along each axis."]
    #[link_name = "\u{1}_ZNK5draco11BoundingBox4SizeEv"]
    pub fn BoundingBox_Size(this: *const BoundingBox) -> Vector3f;
}
extern "C" {
    #[doc = " Returns the center of the bounding box."]
    #[link_name = "\u{1}_ZNK5draco11BoundingBox6CenterEv"]
    pub fn BoundingBox_Center(this: *const BoundingBox) -> Vector3f;
}
extern "C" {
    #[doc = " Creates bounding box object with minimum and maximum points initialized to\n the largest positive and the smallest negative values, respectively. The\n resulting abstract bounding box effectively has no points and can be\n updated by providing any point to Update() method."]
    #[link_name = "\u{1}_ZN5draco11BoundingBoxC1Ev"]
    pub fn BoundingBox_BoundingBox(this: *mut BoundingBox);
}
extern "C" {
    #[doc = " Creates bounding box object with minimum and maximum points initialized to\n |min_point| and |max_point|, respectively."]
    #[link_name = "\u{1}_ZN5draco11BoundingBoxC1ERKNS_7VectorDIfLi3EEES4_"]
    pub fn BoundingBox_BoundingBox1(
        this: *mut BoundingBox,
        min_point: *const Vector3f,
        max_point: *const Vector3f,
    );
}
impl BoundingBox {
    #[inline]
    pub unsafe fn GetMinPoint(&self) -> *const Vector3f {
        BoundingBox_GetMinPoint(self)
    }
    #[inline]
    pub unsafe fn GetMaxPoint(&self) -> *const Vector3f {
        BoundingBox_GetMaxPoint(self)
    }
    #[inline]
    pub unsafe fn IsValid(&self) -> bool {
        BoundingBox_IsValid(self)
    }
    #[inline]
    pub unsafe fn Update(&mut self, new_point: *const Vector3f) {
        BoundingBox_Update(self, new_point)
    }
    #[inline]
    pub unsafe fn Update1(&mut self, other: *const BoundingBox) {
        BoundingBox_Update1(self, other)
    }
    #[inline]
    pub unsafe fn Size(&self) -> Vector3f {
        BoundingBox_Size(self)
    }
    #[inline]
    pub unsafe fn Center(&self) -> Vector3f {
        BoundingBox_Center(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BoundingBox_BoundingBox(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(min_point: *const Vector3f, max_point: *const Vector3f) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        BoundingBox_BoundingBox1(__bindgen_tmp.as_mut_ptr(), min_point, max_point);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Class for storing a value of an entry in Metadata. Internally it is\n represented by a buffer of data. It can be accessed by various data types,\n e.g. int, float, binary data or string."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct EntryValue {
    pub data_: [u64; 3usize],
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10EntryValue4dataEv"]
    pub fn EntryValue_data(this: *const EntryValue) -> *const [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10EntryValueC1ERKS0_"]
    pub fn EntryValue_EntryValue(this: *mut EntryValue, value: *const EntryValue);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10EntryValueC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn EntryValue_EntryValue1(this: *mut EntryValue, value: *const string);
}
impl EntryValue {
    #[inline]
    pub unsafe fn data(&self) -> *const [u64; 3usize] {
        EntryValue_data(self)
    }
    #[inline]
    pub unsafe fn new(value: *const EntryValue) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        EntryValue_EntryValue(__bindgen_tmp.as_mut_ptr(), value);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(value: *const string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        EntryValue_EntryValue1(__bindgen_tmp.as_mut_ptr(), value);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Class for holding generic metadata. It has a list of entries which consist of\n an entry name and an entry value. Each Metadata could also have nested\n metadata."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct Metadata {
    pub entries_: [u64; 6usize],
    pub sub_metadatas_: [u64; 6usize],
}
extern "C" {
    #[doc = " In theory, we support all types of data as long as it could be serialized\n to binary data. We provide the following functions for inserting and\n accessing entries of common data types. For now, developers need to know\n the type of entries they are requesting."]
    #[link_name = "\u{1}_ZN5draco8Metadata11AddEntryIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn Metadata_AddEntryInt(this: *mut Metadata, name: *const string, value: i32);
}
extern "C" {
    #[doc = " Returns false if Metadata does not contain an entry with a key of |name|.\n This function does not guarantee that entry's type is int32_t."]
    #[link_name = "\u{1}_ZNK5draco8Metadata11GetEntryIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPi"]
    pub fn Metadata_GetEntryInt(
        this: *const Metadata,
        name: *const string,
        value: *mut i32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata16AddEntryIntArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorIiSaIiEE"]
    pub fn Metadata_AddEntryIntArray(
        this: *mut Metadata,
        name: *const string,
        value: *const [u64; 3usize],
    );
}
extern "C" {
    #[doc = " Returns false if Metadata does not contain an entry with a key of |name|.\n This function does not guarantee that entry's type is a vector of int32_t."]
    #[link_name = "\u{1}_ZNK5draco8Metadata16GetEntryIntArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPSt6vectorIiSaIiEE"]
    pub fn Metadata_GetEntryIntArray(
        this: *const Metadata,
        name: *const string,
        value: *mut [u64; 3usize],
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata14AddEntryDoubleERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEd"]
    pub fn Metadata_AddEntryDouble(this: *mut Metadata, name: *const string, value: f64);
}
extern "C" {
    #[doc = " Returns false if Metadata does not contain an entry with a key of |name|.\n This function does not guarantee that entry's type is double."]
    #[link_name = "\u{1}_ZNK5draco8Metadata14GetEntryDoubleERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPd"]
    pub fn Metadata_GetEntryDouble(
        this: *const Metadata,
        name: *const string,
        value: *mut f64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata19AddEntryDoubleArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorIdSaIdEE"]
    pub fn Metadata_AddEntryDoubleArray(this: *mut Metadata, name: *const string, value: *const u8);
}
extern "C" {
    #[doc = " Returns false if Metadata does not contain an entry with a key of |name|.\n This function does not guarantee that entry's type is a vector of double."]
    #[link_name = "\u{1}_ZNK5draco8Metadata19GetEntryDoubleArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPSt6vectorIdSaIdEE"]
    pub fn Metadata_GetEntryDoubleArray(
        this: *const Metadata,
        name: *const string,
        value: *mut u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata14AddEntryStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn Metadata_AddEntryString(this: *mut Metadata, name: *const string, value: *const string);
}
extern "C" {
    #[doc = " Returns false if Metadata does not contain an entry with a key of |name|.\n This function does not guarantee that entry's type is std::string."]
    #[link_name = "\u{1}_ZNK5draco8Metadata14GetEntryStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPS6_"]
    pub fn Metadata_GetEntryString(
        this: *const Metadata,
        name: *const string,
        value: *mut string,
    ) -> bool;
}
extern "C" {
    #[doc = " Add a blob of data as an entry."]
    #[link_name = "\u{1}_ZN5draco8Metadata14AddEntryBinaryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorIhSaIhEE"]
    pub fn Metadata_AddEntryBinary(
        this: *mut Metadata,
        name: *const string,
        value: *const [u64; 3usize],
    );
}
extern "C" {
    #[doc = " Returns false if Metadata does not contain an entry with a key of |name|.\n This function does not guarantee that entry's type is a vector of uint8_t."]
    #[link_name = "\u{1}_ZNK5draco8Metadata14GetEntryBinaryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPSt6vectorIhSaIhEE"]
    pub fn Metadata_GetEntryBinary(
        this: *const Metadata,
        name: *const string,
        value: *mut [u64; 3usize],
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata14AddSubMetadataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10unique_ptrIS0_St14default_deleteIS0_EE"]
    pub fn Metadata_AddSubMetadata(
        this: *mut Metadata,
        name: *const string,
        sub_metadata: u64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco8Metadata14GetSubMetadataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Metadata_GetSubMetadata(this: *const Metadata, name: *const string) -> *const Metadata;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata12sub_metadataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Metadata_sub_metadata(this: *mut Metadata, name: *const string) -> *mut Metadata;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata11RemoveEntryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Metadata_RemoveEntry(this: *mut Metadata, name: *const string);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco8Metadata11num_entriesEv"]
    pub fn Metadata_num_entries(this: *const Metadata) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco8Metadata7entriesB5cxx11Ev"]
    pub fn Metadata_entries(this: *const Metadata) -> *const [u64; 6usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco8Metadata13sub_metadatasB5cxx11Ev"]
    pub fn Metadata_sub_metadatas(this: *const Metadata) -> *const [u64; 6usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8MetadataC1Ev"]
    pub fn Metadata_Metadata(this: *mut Metadata);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8MetadataC1ERKS0_"]
    pub fn Metadata_Metadata1(this: *mut Metadata, metadata: *const Metadata);
}
impl Metadata {
    #[inline]
    pub unsafe fn AddEntryInt(&mut self, name: *const string, value: i32) {
        Metadata_AddEntryInt(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryInt(&self, name: *const string, value: *mut i32) -> bool {
        Metadata_GetEntryInt(self, name, value)
    }
    #[inline]
    pub unsafe fn AddEntryIntArray(&mut self, name: *const string, value: *const [u64; 3usize]) {
        Metadata_AddEntryIntArray(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryIntArray(&self, name: *const string, value: *mut [u64; 3usize]) -> bool {
        Metadata_GetEntryIntArray(self, name, value)
    }
    #[inline]
    pub unsafe fn AddEntryDouble(&mut self, name: *const string, value: f64) {
        Metadata_AddEntryDouble(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryDouble(&self, name: *const string, value: *mut f64) -> bool {
        Metadata_GetEntryDouble(self, name, value)
    }
    #[inline]
    pub unsafe fn AddEntryDoubleArray(&mut self, name: *const string, value: *const u8) {
        Metadata_AddEntryDoubleArray(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryDoubleArray(&self, name: *const string, value: *mut u8) -> bool {
        Metadata_GetEntryDoubleArray(self, name, value)
    }
    #[inline]
    pub unsafe fn AddEntryString(&mut self, name: *const string, value: *const string) {
        Metadata_AddEntryString(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryString(&self, name: *const string, value: *mut string) -> bool {
        Metadata_GetEntryString(self, name, value)
    }
    #[inline]
    pub unsafe fn AddEntryBinary(&mut self, name: *const string, value: *const [u64; 3usize]) {
        Metadata_AddEntryBinary(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryBinary(&self, name: *const string, value: *mut [u64; 3usize]) -> bool {
        Metadata_GetEntryBinary(self, name, value)
    }
    #[inline]
    pub unsafe fn AddSubMetadata(&mut self, name: *const string, sub_metadata: u64) -> bool {
        Metadata_AddSubMetadata(self, name, sub_metadata)
    }
    #[inline]
    pub unsafe fn GetSubMetadata(&self, name: *const string) -> *const Metadata {
        Metadata_GetSubMetadata(self, name)
    }
    #[inline]
    pub unsafe fn sub_metadata(&mut self, name: *const string) -> *mut Metadata {
        Metadata_sub_metadata(self, name)
    }
    #[inline]
    pub unsafe fn RemoveEntry(&mut self, name: *const string) {
        Metadata_RemoveEntry(self, name)
    }
    #[inline]
    pub unsafe fn num_entries(&self) -> ::std::os::raw::c_int {
        Metadata_num_entries(self)
    }
    #[inline]
    pub unsafe fn entries(&self) -> *const [u64; 6usize] {
        Metadata_entries(self)
    }
    #[inline]
    pub unsafe fn sub_metadatas(&self) -> *const [u64; 6usize] {
        Metadata_sub_metadatas(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Metadata_Metadata(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(metadata: *const Metadata) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Metadata_Metadata1(__bindgen_tmp.as_mut_ptr(), metadata);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Class for representing specifically metadata of attributes. It must have an\n attribute id which should be identical to it's counterpart attribute in\n the point cloud it belongs to."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct AttributeMetadata {
    pub _base: Metadata,
    pub att_unique_id_: u32,
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17AttributeMetadata17set_att_unique_idEj"]
    pub fn AttributeMetadata_set_att_unique_id(this: *mut AttributeMetadata, att_unique_id: u32);
}
extern "C" {
    #[doc = " The unique id of the attribute that this metadata belongs to."]
    #[link_name = "\u{1}_ZNK5draco17AttributeMetadata13att_unique_idEv"]
    pub fn AttributeMetadata_att_unique_id(this: *const AttributeMetadata) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17AttributeMetadataC1Ev"]
    pub fn AttributeMetadata_AttributeMetadata(this: *mut AttributeMetadata);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17AttributeMetadataC1ERKS0_"]
    pub fn AttributeMetadata_AttributeMetadata1(
        this: *mut AttributeMetadata,
        metadata: *const AttributeMetadata,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17AttributeMetadataC1ERKNS_8MetadataE"]
    pub fn AttributeMetadata_AttributeMetadata2(
        this: *mut AttributeMetadata,
        metadata: *const Metadata,
    );
}
impl AttributeMetadata {
    #[inline]
    pub unsafe fn set_att_unique_id(&mut self, att_unique_id: u32) {
        AttributeMetadata_set_att_unique_id(self, att_unique_id)
    }
    #[inline]
    pub unsafe fn att_unique_id(&self) -> u32 {
        AttributeMetadata_att_unique_id(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AttributeMetadata_AttributeMetadata(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(metadata: *const AttributeMetadata) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AttributeMetadata_AttributeMetadata1(__bindgen_tmp.as_mut_ptr(), metadata);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(metadata: *const Metadata) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AttributeMetadata_AttributeMetadata2(__bindgen_tmp.as_mut_ptr(), metadata);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Class for representing the metadata for a point cloud. It could have a list\n of attribute metadata."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct GeometryMetadata {
    pub _base: Metadata,
    pub att_metadatas_: [u64; 3usize],
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco16GeometryMetadata33GetAttributeMetadataByStringEntryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn GeometryMetadata_GetAttributeMetadataByStringEntry(
        this: *const GeometryMetadata,
        entry_name: *const string,
        entry_value: *const string,
    ) -> *const AttributeMetadata;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco16GeometryMetadata20AddAttributeMetadataESt10unique_ptrINS_17AttributeMetadataESt14default_deleteIS2_EE"]
    pub fn GeometryMetadata_AddAttributeMetadata(
        this: *mut GeometryMetadata,
        att_metadata: u64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco16GeometryMetadata33DeleteAttributeMetadataByUniqueIdEi"]
    pub fn GeometryMetadata_DeleteAttributeMetadataByUniqueId(
        this: *mut GeometryMetadata,
        att_unique_id: i32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco16GeometryMetadata30GetAttributeMetadataByUniqueIdEi"]
    pub fn GeometryMetadata_GetAttributeMetadataByUniqueId(
        this: *const GeometryMetadata,
        att_unique_id: i32,
    ) -> *const AttributeMetadata;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco16GeometryMetadata18attribute_metadataEi"]
    pub fn GeometryMetadata_attribute_metadata(
        this: *mut GeometryMetadata,
        att_unique_id: i32,
    ) -> *mut AttributeMetadata;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco16GeometryMetadata19attribute_metadatasEv"]
    pub fn GeometryMetadata_attribute_metadatas(
        this: *const GeometryMetadata,
    ) -> *const [u64; 3usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco16GeometryMetadataC1Ev"]
    pub fn GeometryMetadata_GeometryMetadata(this: *mut GeometryMetadata);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco16GeometryMetadataC1ERKS0_"]
    pub fn GeometryMetadata_GeometryMetadata1(
        this: *mut GeometryMetadata,
        metadata: *const GeometryMetadata,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco16GeometryMetadataC1ERKNS_8MetadataE"]
    pub fn GeometryMetadata_GeometryMetadata2(
        this: *mut GeometryMetadata,
        metadata: *const Metadata,
    );
}
impl GeometryMetadata {
    #[inline]
    pub unsafe fn GetAttributeMetadataByStringEntry(
        &self,
        entry_name: *const string,
        entry_value: *const string,
    ) -> *const AttributeMetadata {
        GeometryMetadata_GetAttributeMetadataByStringEntry(self, entry_name, entry_value)
    }
    #[inline]
    pub unsafe fn AddAttributeMetadata(&mut self, att_metadata: u64) -> bool {
        GeometryMetadata_AddAttributeMetadata(self, att_metadata)
    }
    #[inline]
    pub unsafe fn DeleteAttributeMetadataByUniqueId(&mut self, att_unique_id: i32) {
        GeometryMetadata_DeleteAttributeMetadataByUniqueId(self, att_unique_id)
    }
    #[inline]
    pub unsafe fn GetAttributeMetadataByUniqueId(
        &self,
        att_unique_id: i32,
    ) -> *const AttributeMetadata {
        GeometryMetadata_GetAttributeMetadataByUniqueId(self, att_unique_id)
    }
    #[inline]
    pub unsafe fn attribute_metadata(&mut self, att_unique_id: i32) -> *mut AttributeMetadata {
        GeometryMetadata_attribute_metadata(self, att_unique_id)
    }
    #[inline]
    pub unsafe fn attribute_metadatas(&self) -> *const [u64; 3usize] {
        GeometryMetadata_attribute_metadatas(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        GeometryMetadata_GeometryMetadata(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(metadata: *const GeometryMetadata) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        GeometryMetadata_GeometryMetadata1(__bindgen_tmp.as_mut_ptr(), metadata);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(metadata: *const Metadata) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        GeometryMetadata_GeometryMetadata2(__bindgen_tmp.as_mut_ptr(), metadata);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct PointCloud__bindgen_vtable(::std::os::raw::c_void);
#[doc = " PointCloud is a collection of n-dimensional points that are described by a\n set of PointAttributes that can represent data such as positions or colors\n of individual points (see point_attribute.h)."]
#[repr(C)]
pub struct PointCloud {
    pub vtable_: *const PointCloud__bindgen_vtable,
    #[doc = " Metadata for the point cloud."]
    pub metadata_: u64,
    #[doc = " Attributes describing the point cloud."]
    pub attributes_: [u64; 3usize],
    #[doc = " Ids of named attributes of the given type."]
    pub named_attribute_index_: [u64; 15usize],
    #[doc = " The number of n-dimensional points. All point attribute values are stored\n in corresponding PointAttribute instances in the |attributes_| array."]
    pub num_points_: ValueType,
}
extern "C" {
    #[doc = " Returns the number of named attributes of a given type."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud18NumNamedAttributesENS_17GeometryAttribute4TypeE"]
    pub fn PointCloud_NumNamedAttributes(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns attribute id of the first named attribute with a given type or -1\n when the attribute is not used by the point cloud."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud19GetNamedAttributeIdENS_17GeometryAttribute4TypeE"]
    pub fn PointCloud_GetNamedAttributeId(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the id of the i-th named attribute of a given type."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud19GetNamedAttributeIdENS_17GeometryAttribute4TypeEi"]
    pub fn PointCloud_GetNamedAttributeId1(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
        i: ::std::os::raw::c_int,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the first named attribute of a given type or nullptr if the\n attribute is not used by the point cloud."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud17GetNamedAttributeENS_17GeometryAttribute4TypeE"]
    pub fn PointCloud_GetNamedAttribute(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
    ) -> *const PointAttribute;
}
extern "C" {
    #[doc = " Returns the i-th named attribute of a given type."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud17GetNamedAttributeENS_17GeometryAttribute4TypeEi"]
    pub fn PointCloud_GetNamedAttribute1(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
        i: ::std::os::raw::c_int,
    ) -> *const PointAttribute;
}
extern "C" {
    #[doc = " Returns the named attribute of a given unique id."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud27GetNamedAttributeByUniqueIdENS_17GeometryAttribute4TypeEj"]
    pub fn PointCloud_GetNamedAttributeByUniqueId(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
        id: u32,
    ) -> *const PointAttribute;
}
extern "C" {
    #[doc = " Returns the attribute of a given unique id."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud22GetAttributeByUniqueIdEj"]
    pub fn PointCloud_GetAttributeByUniqueId(
        this: *const PointCloud,
        id: u32,
    ) -> *const PointAttribute;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud24GetAttributeIdByUniqueIdEj"]
    pub fn PointCloud_GetAttributeIdByUniqueId(this: *const PointCloud, unique_id: u32) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud14num_attributesEv"]
    pub fn PointCloud_num_attributes(this: *const PointCloud) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud9attributeEi"]
    pub fn PointCloud_attribute(this: *const PointCloud, att_id: i32) -> *const PointAttribute;
}
extern "C" {
    #[doc = " Returned attribute can be modified, but it's caller's responsibility to\n maintain the attribute's consistency with draco::PointCloud."]
    #[link_name = "\u{1}_ZN5draco10PointCloud9attributeEi"]
    pub fn PointCloud_attribute1(this: *mut PointCloud, att_id: i32) -> *mut PointAttribute;
}
extern "C" {
    #[doc = " Adds a new attribute to the point cloud.\n Returns the attribute id."]
    #[link_name = "\u{1}_ZN5draco10PointCloud12AddAttributeESt10unique_ptrINS_14PointAttributeESt14default_deleteIS2_EE"]
    pub fn PointCloud_AddAttribute(this: *mut PointCloud, pa: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates and adds a new attribute to the point cloud. The attribute has\n properties derived from the provided GeometryAttribute |att|.\n If |identity_mapping| is set to true, the attribute will use identity\n mapping between point indices and attribute value indices (i.e., each\n point has a unique attribute value). If |identity_mapping| is false, the\n mapping between point indices and attribute value indices is set to\n explicit, and it needs to be initialized manually using the\n PointAttribute::SetPointMapEntry() method. |num_attribute_values| can be\n used to specify the number of attribute values that are going to be\n stored in the newly created attribute. Returns attribute id of the newly\n created attribute or -1 in case of failure."]
    #[link_name = "\u{1}_ZN5draco10PointCloud12AddAttributeERKNS_17GeometryAttributeEbj"]
    pub fn PointCloud_AddAttribute1(
        this: *mut PointCloud,
        att: *const GeometryAttribute,
        identity_mapping: bool,
        num_attribute_values: ValueType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates and returns a new attribute or nullptr in case of failure. This\n method is similar to AddAttribute(), except that it returns the new\n attribute instead of adding it to the point cloud."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud15CreateAttributeERKNS_17GeometryAttributeEbj"]
    pub fn PointCloud_CreateAttribute(
        this: *const PointCloud,
        att: *const GeometryAttribute,
        identity_mapping: bool,
        num_attribute_values: ValueType,
    ) -> u64;
}
extern "C" {
    #[doc = " Get bounding box."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud18ComputeBoundingBoxEv"]
    pub fn PointCloud_ComputeBoundingBox(this: *const PointCloud) -> BoundingBox;
}
extern "C" {
    #[doc = " Add metadata."]
    #[link_name = "\u{1}_ZN5draco10PointCloud11AddMetadataESt10unique_ptrINS_16GeometryMetadataESt14default_deleteIS2_EE"]
    pub fn PointCloud_AddMetadata(this: *mut PointCloud, metadata: u64);
}
extern "C" {
    #[doc = " Add metadata for an attribute."]
    #[link_name = "\u{1}_ZN5draco10PointCloud20AddAttributeMetadataEiSt10unique_ptrINS_17AttributeMetadataESt14default_deleteIS2_EE"]
    pub fn PointCloud_AddAttributeMetadata(this: *mut PointCloud, att_id: i32, metadata: u64);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud33GetAttributeMetadataByAttributeIdEi"]
    pub fn PointCloud_GetAttributeMetadataByAttributeId(
        this: *const PointCloud,
        att_id: i32,
    ) -> *const AttributeMetadata;
}
extern "C" {
    #[doc = " Returns the attribute metadata that has the requested metadata entry."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud33GetAttributeMetadataByStringEntryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn PointCloud_GetAttributeMetadataByStringEntry(
        this: *const PointCloud,
        name: *const string,
        value: *const string,
    ) -> *const AttributeMetadata;
}
extern "C" {
    #[doc = " Returns the first attribute that has the requested metadata entry."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud29GetAttributeIdByMetadataEntryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn PointCloud_GetAttributeIdByMetadataEntry(
        this: *const PointCloud,
        name: *const string,
        value: *const string,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a const pointer of the metadata of the point cloud."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud11GetMetadataEv"]
    pub fn PointCloud_GetMetadata(this: *const PointCloud) -> *const GeometryMetadata;
}
extern "C" {
    #[doc = " Get a pointer to the metadata of the point cloud."]
    #[link_name = "\u{1}_ZN5draco10PointCloud8metadataEv"]
    pub fn PointCloud_metadata(this: *mut PointCloud) -> *mut GeometryMetadata;
}
extern "C" {
    #[doc = " Returns the number of n-dimensional points stored within the point cloud."]
    #[link_name = "\u{1}_ZNK5draco10PointCloud10num_pointsEv"]
    pub fn PointCloud_num_points(this: *const PointCloud) -> ValueType;
}
extern "C" {
    #[doc = " Sets the number of points. It's the caller's responsibility to ensure the\n new number is valid with respect to the PointAttributes stored in the point\n cloud."]
    #[link_name = "\u{1}_ZN5draco10PointCloud14set_num_pointsEj"]
    pub fn PointCloud_set_num_points(this: *mut PointCloud, num: ValueType);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10PointCloudC1Ev"]
    pub fn PointCloud_PointCloud(this: *mut PointCloud);
}
impl Default for PointCloud {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl PointCloud {
    #[inline]
    pub unsafe fn NumNamedAttributes(&self, type_: GeometryAttribute_Type) -> i32 {
        PointCloud_NumNamedAttributes(self, type_)
    }
    #[inline]
    pub unsafe fn GetNamedAttributeId(&self, type_: GeometryAttribute_Type) -> i32 {
        PointCloud_GetNamedAttributeId(self, type_)
    }
    #[inline]
    pub unsafe fn GetNamedAttributeId1(
        &self,
        type_: GeometryAttribute_Type,
        i: ::std::os::raw::c_int,
    ) -> i32 {
        PointCloud_GetNamedAttributeId1(self, type_, i)
    }
    #[inline]
    pub unsafe fn GetNamedAttribute(&self, type_: GeometryAttribute_Type) -> *const PointAttribute {
        PointCloud_GetNamedAttribute(self, type_)
    }
    #[inline]
    pub unsafe fn GetNamedAttribute1(
        &self,
        type_: GeometryAttribute_Type,
        i: ::std::os::raw::c_int,
    ) -> *const PointAttribute {
        PointCloud_GetNamedAttribute1(self, type_, i)
    }
    #[inline]
    pub unsafe fn GetNamedAttributeByUniqueId(
        &self,
        type_: GeometryAttribute_Type,
        id: u32,
    ) -> *const PointAttribute {
        PointCloud_GetNamedAttributeByUniqueId(self, type_, id)
    }
    #[inline]
    pub unsafe fn GetAttributeByUniqueId(&self, id: u32) -> *const PointAttribute {
        PointCloud_GetAttributeByUniqueId(self, id)
    }
    #[inline]
    pub unsafe fn GetAttributeIdByUniqueId(&self, unique_id: u32) -> i32 {
        PointCloud_GetAttributeIdByUniqueId(self, unique_id)
    }
    #[inline]
    pub unsafe fn num_attributes(&self) -> i32 {
        PointCloud_num_attributes(self)
    }
    #[inline]
    pub unsafe fn attribute(&self, att_id: i32) -> *const PointAttribute {
        PointCloud_attribute(self, att_id)
    }
    #[inline]
    pub unsafe fn attribute1(&mut self, att_id: i32) -> *mut PointAttribute {
        PointCloud_attribute1(self, att_id)
    }
    #[inline]
    pub unsafe fn AddAttribute(&mut self, pa: u64) -> ::std::os::raw::c_int {
        PointCloud_AddAttribute(self, pa)
    }
    #[inline]
    pub unsafe fn AddAttribute1(
        &mut self,
        att: *const GeometryAttribute,
        identity_mapping: bool,
        num_attribute_values: ValueType,
    ) -> ::std::os::raw::c_int {
        PointCloud_AddAttribute1(self, att, identity_mapping, num_attribute_values)
    }
    #[inline]
    pub unsafe fn CreateAttribute(
        &self,
        att: *const GeometryAttribute,
        identity_mapping: bool,
        num_attribute_values: ValueType,
    ) -> u64 {
        PointCloud_CreateAttribute(self, att, identity_mapping, num_attribute_values)
    }
    #[inline]
    pub unsafe fn ComputeBoundingBox(&self) -> BoundingBox {
        PointCloud_ComputeBoundingBox(self)
    }
    #[inline]
    pub unsafe fn AddMetadata(&mut self, metadata: u64) {
        PointCloud_AddMetadata(self, metadata)
    }
    #[inline]
    pub unsafe fn AddAttributeMetadata(&mut self, att_id: i32, metadata: u64) {
        PointCloud_AddAttributeMetadata(self, att_id, metadata)
    }
    #[inline]
    pub unsafe fn GetAttributeMetadataByAttributeId(
        &self,
        att_id: i32,
    ) -> *const AttributeMetadata {
        PointCloud_GetAttributeMetadataByAttributeId(self, att_id)
    }
    #[inline]
    pub unsafe fn GetAttributeMetadataByStringEntry(
        &self,
        name: *const string,
        value: *const string,
    ) -> *const AttributeMetadata {
        PointCloud_GetAttributeMetadataByStringEntry(self, name, value)
    }
    #[inline]
    pub unsafe fn GetAttributeIdByMetadataEntry(
        &self,
        name: *const string,
        value: *const string,
    ) -> ::std::os::raw::c_int {
        PointCloud_GetAttributeIdByMetadataEntry(self, name, value)
    }
    #[inline]
    pub unsafe fn GetMetadata(&self) -> *const GeometryMetadata {
        PointCloud_GetMetadata(self)
    }
    #[inline]
    pub unsafe fn metadata(&mut self) -> *mut GeometryMetadata {
        PointCloud_metadata(self)
    }
    #[inline]
    pub unsafe fn num_points(&self) -> ValueType {
        PointCloud_num_points(self)
    }
    #[inline]
    pub unsafe fn set_num_points(&mut self, num: ValueType) {
        PointCloud_set_num_points(self, num)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        PointCloud_PointCloud(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10PointCloudD1Ev"]
    pub fn PointCloud_PointCloud_destructor(this: *mut PointCloud);
}
extern "C" {
    #[doc = " Assigns an attribute id to a given PointAttribute. If an attribute with\n the same attribute id already exists, it is deleted."]
    #[link_name = "\u{1}_ZN5draco10PointCloud12SetAttributeEiSt10unique_ptrINS_14PointAttributeESt14default_deleteIS2_EE"]
    pub fn PointCloud_SetAttribute(
        this: *mut ::std::os::raw::c_void,
        att_id: ::std::os::raw::c_int,
        pa: u64,
    );
}
extern "C" {
    #[doc = " Deletes an attribute with specified attribute id. Note that this changes\n attribute ids of all subsequent attributes."]
    #[link_name = "\u{1}_ZN5draco10PointCloud15DeleteAttributeEi"]
    pub fn PointCloud_DeleteAttribute(
        this: *mut ::std::os::raw::c_void,
        att_id: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Deduplicates all attribute values (all attribute entries with the same\n value are merged into a single entry)."]
    #[link_name = "\u{1}_ZN5draco10PointCloud26DeduplicateAttributeValuesEv"]
    pub fn PointCloud_DeduplicateAttributeValues(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Removes duplicate point ids (two point ids are duplicate when all of their\n attributes are mapped to the same entry ids)."]
    #[link_name = "\u{1}_ZN5draco10PointCloud19DeduplicatePointIdsEv"]
    pub fn PointCloud_DeduplicatePointIds(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Applies id mapping of deduplicated points (called by DeduplicatePointIds)."]
    #[link_name = "\u{1}_ZN5draco10PointCloud25ApplyPointIdDeduplicationERKNS_15IndexTypeVectorINS_9IndexTypeIjNS_20PointIndex_tag_type_EEES4_EERKSt6vectorIS4_SaIS4_EE"]
    pub fn PointCloud_ApplyPointIdDeduplication(
        this: *mut ::std::os::raw::c_void,
        id_map: *const IndexTypeVector,
        unique_point_ids: *const u8,
    );
}
#[doc = " All corners attached to a vertex share the same attribute value. A typical\n example are the vertex positions and often vertex colors."]
pub const MeshAttributeElementType_MESH_VERTEX_ATTRIBUTE: MeshAttributeElementType = 0;
#[doc = " The most general attribute where every corner of the mesh can have a\n different attribute value. Often used for texture coordinates or normals."]
pub const MeshAttributeElementType_MESH_CORNER_ATTRIBUTE: MeshAttributeElementType = 1;
#[doc = " All corners of a single face share the same value."]
pub const MeshAttributeElementType_MESH_FACE_ATTRIBUTE: MeshAttributeElementType = 2;
#[doc = " List of different variants of mesh attributes."]
pub type MeshAttributeElementType = ::std::os::raw::c_uint;
#[doc = " Mesh class can be used to represent general triangular meshes. Internally,\n Mesh is just an extended PointCloud with extra connectivity data that defines\n what points are connected together in triangles."]
#[repr(C)]
pub struct Mesh {
    pub _base: PointCloud,
    #[doc = " Mesh specific per-attribute data."]
    pub attribute_data_: [u64; 3usize],
    #[doc = " Vertex indices valid for all attributes. Each attribute has its own map\n that converts vertex indices into attribute indices."]
    pub faces_: IndexTypeVector,
}
#[doc = "  @brief A standard container for storing a fixed size sequence of elements.\n\n  @ingroup sequences\n\n  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n  <a href=\"tables.html#66\">reversible container</a>, and a\n  <a href=\"tables.html#67\">sequence</a>.\n\n  Sets support random access iterators.\n\n  @tparam  Tp  Type of element. Required to be a complete type.\n  @tparam  Nm  Number of elements."]
pub type Mesh_Face = [u32; 3usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mesh_AttributeData {
    pub element_type: MeshAttributeElementType,
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco4Mesh13AttributeDataC1Ev"]
    pub fn Mesh_AttributeData_AttributeData(this: *mut Mesh_AttributeData);
}
impl Default for Mesh_AttributeData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Mesh_AttributeData {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Mesh_AttributeData_AttributeData(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco4Mesh7AddFaceERKSt5arrayINS_9IndexTypeIjNS_20PointIndex_tag_type_EEELm3EE"]
    pub fn Mesh_AddFace(this: *mut Mesh, face: *const Mesh_Face);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco4Mesh7SetFaceENS_9IndexTypeIjNS_19FaceIndex_tag_type_EEERKSt5arrayINS1_IjNS_20PointIndex_tag_type_EEELm3EE"]
    pub fn Mesh_SetFace(this: *mut Mesh, face_id: FaceIndex, face: *const Mesh_Face);
}
extern "C" {
    #[doc = " Sets the total number of faces. Creates new empty faces or deletes\n existing ones if necessary."]
    #[link_name = "\u{1}_ZN5draco4Mesh11SetNumFacesEm"]
    pub fn Mesh_SetNumFaces(this: *mut Mesh, num_faces: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco4Mesh9num_facesEv"]
    pub fn Mesh_num_faces(this: *const Mesh) -> ValueType;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco4Mesh4faceENS_9IndexTypeIjNS_19FaceIndex_tag_type_EEE"]
    pub fn Mesh_face(this: *const Mesh, face_id: FaceIndex) -> *const Mesh_Face;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco4Mesh23GetAttributeElementTypeEi"]
    pub fn Mesh_GetAttributeElementType(
        this: *const Mesh,
        att_id: ::std::os::raw::c_int,
    ) -> MeshAttributeElementType;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco4Mesh23SetAttributeElementTypeEiNS_24MeshAttributeElementTypeE"]
    pub fn Mesh_SetAttributeElementType(
        this: *mut Mesh,
        att_id: ::std::os::raw::c_int,
        et: MeshAttributeElementType,
    );
}
extern "C" {
    #[doc = " Returns the point id of for a corner |ci|."]
    #[link_name = "\u{1}_ZNK5draco4Mesh15CornerToPointIdEi"]
    pub fn Mesh_CornerToPointId(this: *const Mesh, ci: ::std::os::raw::c_int) -> PointIndex;
}
extern "C" {
    #[doc = " Returns the point id of a corner |ci|."]
    #[link_name = "\u{1}_ZNK5draco4Mesh15CornerToPointIdENS_9IndexTypeIjNS_21CornerIndex_tag_type_EEE"]
    pub fn Mesh_CornerToPointId1(this: *const Mesh, ci: CornerIndex) -> PointIndex;
}
extern "C" {
    #[doc = " Exposes |faces_|. Use |faces_| at your own risk. DO NOT store the\n reference: the |faces_| object is destroyed with the mesh."]
    #[link_name = "\u{1}_ZN5draco4Mesh5facesEv"]
    pub fn Mesh_faces(this: *mut Mesh) -> *mut IndexTypeVector;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco4MeshC1Ev"]
    pub fn Mesh_Mesh(this: *mut Mesh);
}
impl Default for Mesh {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Mesh {
    #[inline]
    pub unsafe fn AddFace(&mut self, face: *const Mesh_Face) {
        Mesh_AddFace(self, face)
    }
    #[inline]
    pub unsafe fn SetFace(&mut self, face_id: FaceIndex, face: *const Mesh_Face) {
        Mesh_SetFace(self, face_id, face)
    }
    #[inline]
    pub unsafe fn SetNumFaces(&mut self, num_faces: usize) {
        Mesh_SetNumFaces(self, num_faces)
    }
    #[inline]
    pub unsafe fn num_faces(&self) -> ValueType {
        Mesh_num_faces(self)
    }
    #[inline]
    pub unsafe fn face(&self, face_id: FaceIndex) -> *const Mesh_Face {
        Mesh_face(self, face_id)
    }
    #[inline]
    pub unsafe fn GetAttributeElementType(
        &self,
        att_id: ::std::os::raw::c_int,
    ) -> MeshAttributeElementType {
        Mesh_GetAttributeElementType(self, att_id)
    }
    #[inline]
    pub unsafe fn SetAttributeElementType(
        &mut self,
        att_id: ::std::os::raw::c_int,
        et: MeshAttributeElementType,
    ) {
        Mesh_SetAttributeElementType(self, att_id, et)
    }
    #[inline]
    pub unsafe fn CornerToPointId(&self, ci: ::std::os::raw::c_int) -> PointIndex {
        Mesh_CornerToPointId(self, ci)
    }
    #[inline]
    pub unsafe fn CornerToPointId1(&self, ci: CornerIndex) -> PointIndex {
        Mesh_CornerToPointId1(self, ci)
    }
    #[inline]
    pub unsafe fn faces(&mut self) -> *mut IndexTypeVector {
        Mesh_faces(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Mesh_Mesh(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco4Mesh12SetAttributeEiSt10unique_ptrINS_14PointAttributeESt14default_deleteIS2_EE"]
    pub fn Mesh_SetAttribute(
        this: *mut ::std::os::raw::c_void,
        att_id: ::std::os::raw::c_int,
        pa: u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco4Mesh15DeleteAttributeEi"]
    pub fn Mesh_DeleteAttribute(this: *mut ::std::os::raw::c_void, att_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Extends the point deduplication to face corners. This method is called from\n the PointCloud::DeduplicatePointIds() and it remaps all point ids stored in\n |faces_| to the new deduplicated point ids using the map |id_map|."]
    #[link_name = "\u{1}_ZN5draco4Mesh25ApplyPointIdDeduplicationERKNS_15IndexTypeVectorINS_9IndexTypeIjNS_20PointIndex_tag_type_EEES4_EERKSt6vectorIS4_SaIS4_EE"]
    pub fn Mesh_ApplyPointIdDeduplication(
        this: *mut ::std::os::raw::c_void,
        id_map: *const IndexTypeVector,
        unique_point_ids: *const u8,
    );
}
#[doc = " Basic helper class for encoding geometry using the Draco compression library.\n The class provides various methods that can be used to control several common\n options used during the encoding, such as the number of quantization bits for\n a given attribute. All these options are defined per attribute type, i.e.,\n if there are more attributes of the same type (such as multiple texture\n coordinate attributes), the same options are going to be used for all of the\n attributes of this type. If different attributes of the same type need to\n use different options, use ExpertEncoder in expert_encode.h."]
#[repr(C)]
#[derive(Debug)]
pub struct Encoder {
    pub _base: EncoderBase<EncoderOptionsBase>,
}
#[doc = " Base class for our geometry encoder classes. |EncoderOptionsT| specifies\n options class used by the encoder. Please, see encode.h and expert_encode.h\n for more details and method descriptions."]
pub type Encoder_Base = EncoderBase<EncoderOptionsBase>;
extern "C" {
    #[doc = " Set encoder options used during the geometry encoding. Note that this call\n overwrites any modifications to the options done with the functions below,\n i.e., it resets the encoder."]
    #[link_name = "\u{1}_ZN5draco7Encoder5ResetERKNS_18EncoderOptionsBaseINS_17GeometryAttribute4TypeEEE"]
    pub fn Encoder_Reset(this: *mut Encoder, options: *const EncoderOptionsBase);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Encoder5ResetEv"]
    pub fn Encoder_Reset1(this: *mut Encoder);
}
extern "C" {
    #[doc = " Sets the desired encoding and decoding speed for the given options.\n\n  0 = slowest speed, but the best compression.\n 10 = fastest, but the worst compression.\n -1 = undefined.\n\n Note that both speed options affect the encoder choice of used methods and\n algorithms. For example, a requirement for fast decoding may prevent the\n encoder from using the best compression methods even if the encoding speed\n is set to 0. In general, the faster of the two options limits the choice of\n features that can be used by the encoder. Additionally, setting\n |decoding_speed| to be faster than the |encoding_speed| may allow the\n encoder to choose the optimal method out of the available features for the\n given |decoding_speed|."]
    #[link_name = "\u{1}_ZN5draco7Encoder15SetSpeedOptionsEii"]
    pub fn Encoder_SetSpeedOptions(
        this: *mut Encoder,
        encoding_speed: ::std::os::raw::c_int,
        decoding_speed: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sets the quantization compression options for a named attribute. The\n attribute values will be quantized in a box defined by the maximum extent\n of the attribute values. I.e., the actual precision of this option depends\n on the scale of the attribute values."]
    #[link_name = "\u{1}_ZN5draco7Encoder24SetAttributeQuantizationENS_17GeometryAttribute4TypeEi"]
    pub fn Encoder_SetAttributeQuantization(
        this: *mut Encoder,
        type_: GeometryAttribute_Type,
        quantization_bits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sets the explicit quantization compression for a named attribute. The\n attribute values will be quantized in a coordinate system defined by the\n provided origin and range (the input values should be within interval:\n <origin, origin + range>)."]
    #[link_name = "\u{1}_ZN5draco7Encoder32SetAttributeExplicitQuantizationENS_17GeometryAttribute4TypeEiiPKff"]
    pub fn Encoder_SetAttributeExplicitQuantization(
        this: *mut Encoder,
        type_: GeometryAttribute_Type,
        quantization_bits: ::std::os::raw::c_int,
        num_dims: ::std::os::raw::c_int,
        origin: *const f32,
        range: f32,
    );
}
extern "C" {
    #[doc = " Sets the desired prediction method for a given attribute. By default,\n prediction scheme is selected automatically by the encoder using other\n provided options (such as speed) and input geometry type (mesh, point\n cloud). This function should be called only when a specific prediction is\n preferred (e.g., when it is known that the encoder would select a less\n optimal prediction for the given input data).\n\n |prediction_scheme_method| should be one of the entries defined in\n compression/config/compression_shared.h :\n\n   PREDICTION_NONE - use no prediction.\n   PREDICTION_DIFFERENCE - delta coding\n   MESH_PREDICTION_PARALLELOGRAM - parallelogram prediction for meshes.\n   MESH_PREDICTION_CONSTRAINED_PARALLELOGRAM\n      - better and more costly version of the parallelogram prediction.\n   MESH_PREDICTION_TEX_COORDS_PORTABLE\n      - specialized predictor for tex coordinates.\n   MESH_PREDICTION_GEOMETRIC_NORMAL\n      - specialized predictor for normal coordinates.\n\n Note that in case the desired prediction cannot be used, the default\n prediction will be automatically used instead."]
    #[link_name = "\u{1}_ZN5draco7Encoder28SetAttributePredictionSchemeENS_17GeometryAttribute4TypeEi"]
    pub fn Encoder_SetAttributePredictionScheme(
        this: *mut Encoder,
        type_: GeometryAttribute_Type,
        prediction_scheme_method: ::std::os::raw::c_int,
    ) -> Status;
}
extern "C" {
    #[doc = " Sets the desired encoding method for a given geometry. By default, encoding\n method is selected based on the properties of the input geometry and based\n on the other options selected in the used EncoderOptions (such as desired\n encoding and decoding speed). This function should be called only when a\n specific method is required.\n\n |encoding_method| can be one of the values defined in\n compression/config/compression_shared.h based on the type of the input\n geometry that is going to be encoded. For point clouds, allowed entries are\n   POINT_CLOUD_SEQUENTIAL_ENCODING\n   POINT_CLOUD_KD_TREE_ENCODING\n\n For meshes the input can be\n   MESH_SEQUENTIAL_ENCODING\n   MESH_EDGEBREAKER_ENCODING\n\n If the selected method cannot be used for the given input, the subsequent\n call of EncodePointCloudToBuffer or EncodeMeshToBuffer is going to fail."]
    #[link_name = "\u{1}_ZN5draco7Encoder17SetEncodingMethodEi"]
    pub fn Encoder_SetEncodingMethod(this: *mut Encoder, encoding_method: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Creates encoder options for the expert encoder used during the actual\n encoding."]
    #[link_name = "\u{1}_ZNK5draco7Encoder26CreateExpertEncoderOptionsERKNS_10PointCloudE"]
    pub fn Encoder_CreateExpertEncoderOptions(
        this: *const Encoder,
        pc: *const PointCloud,
    ) -> EncoderOptions;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7EncoderC1Ev"]
    pub fn Encoder_Encoder(this: *mut Encoder);
}
impl Default for Encoder {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Encoder {
    #[inline]
    pub unsafe fn Reset(&mut self, options: *const EncoderOptionsBase) {
        Encoder_Reset(self, options)
    }
    #[inline]
    pub unsafe fn Reset1(&mut self) {
        Encoder_Reset1(self)
    }
    #[inline]
    pub unsafe fn SetSpeedOptions(
        &mut self,
        encoding_speed: ::std::os::raw::c_int,
        decoding_speed: ::std::os::raw::c_int,
    ) {
        Encoder_SetSpeedOptions(self, encoding_speed, decoding_speed)
    }
    #[inline]
    pub unsafe fn SetAttributeQuantization(
        &mut self,
        type_: GeometryAttribute_Type,
        quantization_bits: ::std::os::raw::c_int,
    ) {
        Encoder_SetAttributeQuantization(self, type_, quantization_bits)
    }
    #[inline]
    pub unsafe fn SetAttributeExplicitQuantization(
        &mut self,
        type_: GeometryAttribute_Type,
        quantization_bits: ::std::os::raw::c_int,
        num_dims: ::std::os::raw::c_int,
        origin: *const f32,
        range: f32,
    ) {
        Encoder_SetAttributeExplicitQuantization(
            self,
            type_,
            quantization_bits,
            num_dims,
            origin,
            range,
        )
    }
    #[inline]
    pub unsafe fn SetAttributePredictionScheme(
        &mut self,
        type_: GeometryAttribute_Type,
        prediction_scheme_method: ::std::os::raw::c_int,
    ) -> Status {
        Encoder_SetAttributePredictionScheme(self, type_, prediction_scheme_method)
    }
    #[inline]
    pub unsafe fn SetEncodingMethod(&mut self, encoding_method: ::std::os::raw::c_int) {
        Encoder_SetEncodingMethod(self, encoding_method)
    }
    #[inline]
    pub unsafe fn CreateExpertEncoderOptions(&self, pc: *const PointCloud) -> EncoderOptions {
        Encoder_CreateExpertEncoderOptions(self, pc)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Encoder_Encoder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7EncoderD1Ev"]
    pub fn Encoder_Encoder_destructor(this: *mut Encoder);
}
extern "C" {
    #[doc = " Encodes a point cloud to the provided buffer."]
    #[link_name = "\u{1}_ZN5draco7Encoder24EncodePointCloudToBufferERKNS_10PointCloudEPNS_13EncoderBufferE"]
    pub fn Encoder_EncodePointCloudToBuffer(
        this: *mut ::std::os::raw::c_void,
        pc: *const PointCloud,
        out_buffer: *mut EncoderBuffer,
    ) -> Status;
}
extern "C" {
    #[doc = " Encodes a mesh to the provided buffer."]
    #[link_name = "\u{1}_ZN5draco7Encoder18EncodeMeshToBufferERKNS_4MeshEPNS_13EncoderBufferE"]
    pub fn Encoder_EncodeMeshToBuffer(
        this: *mut ::std::os::raw::c_void,
        m: *const Mesh,
        out_buffer: *mut EncoderBuffer,
    ) -> Status;
}
#[doc = " Class containing options that can be passed to PointCloudDecoder to control\n decoding of the input geometry. The options can be specified either for the\n whole geometry or for a specific attribute type. Each option is identified\n by a unique name stored as an std::string."]
pub type DecoderOptions = DracoOptions;
#[doc = " Class is a wrapper around input data used by MeshDecoder. It provides a\n basic interface for decoding either typed or variable-bit sized data."]
#[repr(C)]
#[derive(Debug)]
pub struct DecoderBuffer {
    pub data_: *const ::std::os::raw::c_char,
    pub data_size_: i64,
    #[doc = " Current parsing position of the decoder."]
    pub pos_: i64,
    pub bit_decoder_: DecoderBuffer_BitDecoder,
    pub bit_mode_: bool,
    pub bitstream_version_: u16,
}
#[doc = " Internal helper class to decode bits from a bit buffer."]
#[repr(C)]
#[derive(Debug)]
pub struct DecoderBuffer_BitDecoder {
    pub bit_buffer_: *const u8,
    pub bit_buffer_end_: *const u8,
    pub bit_offset_: usize,
}
extern "C" {
    #[doc = " Sets the bit buffer to |b|. |s| is the size of |b| in bytes."]
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer10BitDecoder5resetEPKvm"]
    pub fn DecoderBuffer_BitDecoder_reset(
        this: *mut DecoderBuffer_BitDecoder,
        b: *const ::std::os::raw::c_void,
        s: usize,
    );
}
extern "C" {
    #[doc = " Returns number of bits decoded so far."]
    #[link_name = "\u{1}_ZNK5draco13DecoderBuffer10BitDecoder11BitsDecodedEv"]
    pub fn DecoderBuffer_BitDecoder_BitsDecoded(this: *const DecoderBuffer_BitDecoder) -> u64;
}
extern "C" {
    #[doc = " Return number of bits available for decoding"]
    #[link_name = "\u{1}_ZNK5draco13DecoderBuffer10BitDecoder9AvailBitsEv"]
    pub fn DecoderBuffer_BitDecoder_AvailBits(this: *const DecoderBuffer_BitDecoder) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer10BitDecoder10EnsureBitsEi"]
    pub fn DecoderBuffer_BitDecoder_EnsureBits(
        this: *mut DecoderBuffer_BitDecoder,
        k: ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer10BitDecoder11ConsumeBitsEi"]
    pub fn DecoderBuffer_BitDecoder_ConsumeBits(
        this: *mut DecoderBuffer_BitDecoder,
        k: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Returns |nbits| bits in |x|."]
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer10BitDecoder7GetBitsEjPj"]
    pub fn DecoderBuffer_BitDecoder_GetBits(
        this: *mut DecoderBuffer_BitDecoder,
        nbits: u32,
        x: *mut u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer10BitDecoderC1Ev"]
    pub fn DecoderBuffer_BitDecoder_BitDecoder(this: *mut DecoderBuffer_BitDecoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer10BitDecoderD1Ev"]
    pub fn DecoderBuffer_BitDecoder_BitDecoder_destructor(this: *mut DecoderBuffer_BitDecoder);
}
impl Default for DecoderBuffer_BitDecoder {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl DecoderBuffer_BitDecoder {
    #[inline]
    pub unsafe fn reset(&mut self, b: *const ::std::os::raw::c_void, s: usize) {
        DecoderBuffer_BitDecoder_reset(self, b, s)
    }
    #[inline]
    pub unsafe fn BitsDecoded(&self) -> u64 {
        DecoderBuffer_BitDecoder_BitsDecoded(self)
    }
    #[inline]
    pub unsafe fn AvailBits(&self) -> u64 {
        DecoderBuffer_BitDecoder_AvailBits(self)
    }
    #[inline]
    pub unsafe fn EnsureBits(&mut self, k: ::std::os::raw::c_int) -> u32 {
        DecoderBuffer_BitDecoder_EnsureBits(self, k)
    }
    #[inline]
    pub unsafe fn ConsumeBits(&mut self, k: ::std::os::raw::c_int) {
        DecoderBuffer_BitDecoder_ConsumeBits(self, k)
    }
    #[inline]
    pub unsafe fn GetBits(&mut self, nbits: u32, x: *mut u32) -> bool {
        DecoderBuffer_BitDecoder_GetBits(self, nbits, x)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        DecoderBuffer_BitDecoder_BitDecoder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        DecoderBuffer_BitDecoder_BitDecoder_destructor(self)
    }
}
extern "C" {
    #[doc = " Sets the buffer's internal data. Note that no copy of the input data is\n made so the data owner needs to keep the data valid and unchanged for\n runtime of the decoder."]
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer4InitEPKcm"]
    pub fn DecoderBuffer_Init(
        this: *mut DecoderBuffer,
        data: *const ::std::os::raw::c_char,
        data_size: usize,
    );
}
extern "C" {
    #[doc = " Sets the buffer's internal data. |version| is the Draco bitstream version."]
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer4InitEPKcmt"]
    pub fn DecoderBuffer_Init1(
        this: *mut DecoderBuffer,
        data: *const ::std::os::raw::c_char,
        data_size: usize,
        version: u16,
    );
}
extern "C" {
    #[doc = " Starts decoding a bit sequence.\n decode_size must be true if the size of the encoded bit data was included,\n during encoding. The size is then returned to out_size.\n Returns false on error."]
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer16StartBitDecodingEbPm"]
    pub fn DecoderBuffer_StartBitDecoding(
        this: *mut DecoderBuffer,
        decode_size: bool,
        out_size: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Ends the decoding of the bit sequence and return to the default\n byte-aligned decoding."]
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer14EndBitDecodingEv"]
    pub fn DecoderBuffer_EndBitDecoding(this: *mut DecoderBuffer);
}
extern "C" {
    #[doc = " Decodes up to 32 bits into out_val. Can be called only in between\n StartBitDecoding and EndBitDecoding. Otherwise returns false."]
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer28DecodeLeastSignificantBits32EjPj"]
    pub fn DecoderBuffer_DecodeLeastSignificantBits32(
        this: *mut DecoderBuffer,
        nbits: u32,
        out_value: *mut u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer6DecodeEPvm"]
    pub fn DecoderBuffer_Decode(
        this: *mut DecoderBuffer,
        out_data: *mut ::std::os::raw::c_void,
        size_to_decode: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer4PeekEPvm"]
    pub fn DecoderBuffer_Peek(
        this: *mut DecoderBuffer,
        out_data: *mut ::std::os::raw::c_void,
        size_to_peek: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Discards #bytes from the input buffer."]
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer7AdvanceEl"]
    pub fn DecoderBuffer_Advance(this: *mut DecoderBuffer, bytes: i64);
}
extern "C" {
    #[doc = " Moves the parsing position to a specific offset from the beginning of the\n input data."]
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer17StartDecodingFromEl"]
    pub fn DecoderBuffer_StartDecodingFrom(this: *mut DecoderBuffer, offset: i64);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer21set_bitstream_versionEt"]
    pub fn DecoderBuffer_set_bitstream_version(this: *mut DecoderBuffer, version: u16);
}
extern "C" {
    #[doc = " Returns the data array at the current decoder position."]
    #[link_name = "\u{1}_ZNK5draco13DecoderBuffer9data_headEv"]
    pub fn DecoderBuffer_data_head(this: *const DecoderBuffer) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco13DecoderBuffer14remaining_sizeEv"]
    pub fn DecoderBuffer_remaining_size(this: *const DecoderBuffer) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco13DecoderBuffer12decoded_sizeEv"]
    pub fn DecoderBuffer_decoded_size(this: *const DecoderBuffer) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco13DecoderBuffer18bit_decoder_activeEv"]
    pub fn DecoderBuffer_bit_decoder_active(this: *const DecoderBuffer) -> bool;
}
extern "C" {
    #[doc = " Returns the bitstream associated with the data. Returns 0 if unknown."]
    #[link_name = "\u{1}_ZNK5draco13DecoderBuffer17bitstream_versionEv"]
    pub fn DecoderBuffer_bitstream_version(this: *const DecoderBuffer) -> u16;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBufferC1Ev"]
    pub fn DecoderBuffer_DecoderBuffer(this: *mut DecoderBuffer);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBufferC1ERKS0_"]
    pub fn DecoderBuffer_DecoderBuffer1(this: *mut DecoderBuffer, buf: *const DecoderBuffer);
}
impl Default for DecoderBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl DecoderBuffer {
    #[inline]
    pub unsafe fn Init(&mut self, data: *const ::std::os::raw::c_char, data_size: usize) {
        DecoderBuffer_Init(self, data, data_size)
    }
    #[inline]
    pub unsafe fn Init1(
        &mut self,
        data: *const ::std::os::raw::c_char,
        data_size: usize,
        version: u16,
    ) {
        DecoderBuffer_Init1(self, data, data_size, version)
    }
    #[inline]
    pub unsafe fn StartBitDecoding(&mut self, decode_size: bool, out_size: *mut u64) -> bool {
        DecoderBuffer_StartBitDecoding(self, decode_size, out_size)
    }
    #[inline]
    pub unsafe fn EndBitDecoding(&mut self) {
        DecoderBuffer_EndBitDecoding(self)
    }
    #[inline]
    pub unsafe fn DecodeLeastSignificantBits32(&mut self, nbits: u32, out_value: *mut u32) -> bool {
        DecoderBuffer_DecodeLeastSignificantBits32(self, nbits, out_value)
    }
    #[inline]
    pub unsafe fn Decode(
        &mut self,
        out_data: *mut ::std::os::raw::c_void,
        size_to_decode: usize,
    ) -> bool {
        DecoderBuffer_Decode(self, out_data, size_to_decode)
    }
    #[inline]
    pub unsafe fn Peek(
        &mut self,
        out_data: *mut ::std::os::raw::c_void,
        size_to_peek: usize,
    ) -> bool {
        DecoderBuffer_Peek(self, out_data, size_to_peek)
    }
    #[inline]
    pub unsafe fn Advance(&mut self, bytes: i64) {
        DecoderBuffer_Advance(self, bytes)
    }
    #[inline]
    pub unsafe fn StartDecodingFrom(&mut self, offset: i64) {
        DecoderBuffer_StartDecodingFrom(self, offset)
    }
    #[inline]
    pub unsafe fn set_bitstream_version(&mut self, version: u16) {
        DecoderBuffer_set_bitstream_version(self, version)
    }
    #[inline]
    pub unsafe fn data_head(&self) -> *const ::std::os::raw::c_char {
        DecoderBuffer_data_head(self)
    }
    #[inline]
    pub unsafe fn remaining_size(&self) -> i64 {
        DecoderBuffer_remaining_size(self)
    }
    #[inline]
    pub unsafe fn decoded_size(&self) -> i64 {
        DecoderBuffer_decoded_size(self)
    }
    #[inline]
    pub unsafe fn bit_decoder_active(&self) -> bool {
        DecoderBuffer_bit_decoder_active(self)
    }
    #[inline]
    pub unsafe fn bitstream_version(&self) -> u16 {
        DecoderBuffer_bitstream_version(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        DecoderBuffer_DecoderBuffer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(buf: *const DecoderBuffer) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        DecoderBuffer_DecoderBuffer1(__bindgen_tmp.as_mut_ptr(), buf);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Class StatusOr is used to wrap a Status along with a value of a specified\n type |T|. StatusOr is intended to be returned from functions in situations\n where it is desirable to carry over more information about the potential\n errors encountered during the function execution. If there are not errors,\n the caller can simply use the return value, otherwise the Status object\n provides more info about the encountered problem."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StatusOr<T> {
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    pub status_: Status,
    pub value_: T,
}
impl<T> Default for StatusOr<T> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Class responsible for decoding of meshes and point clouds that were\n compressed by a Draco encoder."]
#[repr(C)]
#[derive(Debug)]
pub struct Decoder {
    pub options_: DecoderOptions,
}
extern "C" {
    #[doc = " Returns the geometry type encoded in the input |in_buffer|.\n The return value is one of POINT_CLOUD, MESH or INVALID_GEOMETRY in case\n the input data is invalid.\n The decoded geometry type can be used to choose an appropriate decoding\n function for a given geometry type (see below)."]
    #[link_name = "\u{1}_ZN5draco7Decoder22GetEncodedGeometryTypeEPNS_13DecoderBufferE"]
    pub fn Decoder_GetEncodedGeometryType(
        in_buffer: *mut DecoderBuffer,
    ) -> StatusOr<EncodedGeometryType>;
}
extern "C" {
    #[doc = " Decodes point cloud from the provided buffer. The buffer must be filled\n with data that was encoded with either the EncodePointCloudToBuffer or\n EncodeMeshToBuffer methods in encode.h. In case the input buffer contains\n mesh, the returned instance can be down-casted to Mesh."]
    #[link_name = "\u{1}_ZN5draco7Decoder26DecodePointCloudFromBufferEPNS_13DecoderBufferE"]
    pub fn Decoder_DecodePointCloudFromBuffer(
        this: *mut Decoder,
        in_buffer: *mut DecoderBuffer,
    ) -> u8;
}
extern "C" {
    #[doc = " Decodes a triangular mesh from the provided buffer. The mesh must be filled\n with data that was encoded using the EncodeMeshToBuffer method in encode.h.\n The function will return nullptr in case the input is invalid or if it was\n encoded with the EncodePointCloudToBuffer method."]
    #[link_name = "\u{1}_ZN5draco7Decoder20DecodeMeshFromBufferEPNS_13DecoderBufferE"]
    pub fn Decoder_DecodeMeshFromBuffer(this: *mut Decoder, in_buffer: *mut DecoderBuffer) -> u8;
}
extern "C" {
    #[doc = " Decodes the buffer into a provided geometry. If the geometry is\n incompatible with the encoded data. For example, when |out_geometry| is\n draco::Mesh while the data contains a point cloud, the function will return\n an error status."]
    #[link_name = "\u{1}_ZN5draco7Decoder22DecodeBufferToGeometryEPNS_13DecoderBufferEPNS_10PointCloudE"]
    pub fn Decoder_DecodeBufferToGeometry(
        this: *mut Decoder,
        in_buffer: *mut DecoderBuffer,
        out_geometry: *mut PointCloud,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Decoder22DecodeBufferToGeometryEPNS_13DecoderBufferEPNS_4MeshE"]
    pub fn Decoder_DecodeBufferToGeometry1(
        this: *mut Decoder,
        in_buffer: *mut DecoderBuffer,
        out_geometry: *mut Mesh,
    ) -> Status;
}
extern "C" {
    #[doc = " When set, the decoder is going to skip attribute transform for a given\n attribute type. For example for quantized attributes, the decoder would\n skip the dequantization step and the returned geometry would contain an\n attribute with quantized values. The attribute would also contain an\n instance of AttributeTransform class that is used to describe the skipped\n transform, including all parameters that are needed to perform the\n transform manually."]
    #[link_name = "\u{1}_ZN5draco7Decoder25SetSkipAttributeTransformENS_17GeometryAttribute4TypeE"]
    pub fn Decoder_SetSkipAttributeTransform(this: *mut Decoder, att_type: GeometryAttribute_Type);
}
extern "C" {
    #[doc = " Returns the options instance used by the decoder that can be used by users\n to control the decoding process."]
    #[link_name = "\u{1}_ZN5draco7Decoder7optionsEv"]
    pub fn Decoder_options(this: *mut Decoder) -> *mut DecoderOptions;
}
impl Default for Decoder {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Decoder {
    #[inline]
    pub unsafe fn GetEncodedGeometryType(
        in_buffer: *mut DecoderBuffer,
    ) -> StatusOr<EncodedGeometryType> {
        Decoder_GetEncodedGeometryType(in_buffer)
    }
    #[inline]
    pub unsafe fn DecodePointCloudFromBuffer(&mut self, in_buffer: *mut DecoderBuffer) -> u8 {
        Decoder_DecodePointCloudFromBuffer(self, in_buffer)
    }
    #[inline]
    pub unsafe fn DecodeMeshFromBuffer(&mut self, in_buffer: *mut DecoderBuffer) -> u8 {
        Decoder_DecodeMeshFromBuffer(self, in_buffer)
    }
    #[inline]
    pub unsafe fn DecodeBufferToGeometry(
        &mut self,
        in_buffer: *mut DecoderBuffer,
        out_geometry: *mut PointCloud,
    ) -> Status {
        Decoder_DecodeBufferToGeometry(self, in_buffer, out_geometry)
    }
    #[inline]
    pub unsafe fn DecodeBufferToGeometry1(
        &mut self,
        in_buffer: *mut DecoderBuffer,
        out_geometry: *mut Mesh,
    ) -> Status {
        Decoder_DecodeBufferToGeometry1(self, in_buffer, out_geometry)
    }
    #[inline]
    pub unsafe fn SetSkipAttributeTransform(&mut self, att_type: GeometryAttribute_Type) {
        Decoder_SetSkipAttributeTransform(self, att_type)
    }
    #[inline]
    pub unsafe fn options(&mut self) -> *mut DecoderOptions {
        Decoder_options(self)
    }
}
#[repr(C)]
pub struct AttributesEncoder__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Base class for encoding one or more attributes of a PointCloud (or other\n geometry). This base class provides only the basic interface that is used\n by the PointCloudEncoder."]
#[repr(C)]
#[derive(Debug)]
pub struct AttributesEncoder {
    pub vtable_: *const AttributesEncoder__bindgen_vtable,
    #[doc = " List of attribute ids that need to be encoded with this encoder."]
    pub point_attribute_ids_: [u64; 3usize],
    #[doc = " Map between point attribute id and the local id (i.e., the inverse of the\n |point_attribute_ids_|."]
    pub point_attribute_to_local_id_map_: [u64; 3usize],
    pub point_cloud_encoder_: *mut PointCloudEncoder,
    pub point_cloud_: *const PointCloud,
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17AttributesEncoder14AddAttributeIdEi"]
    pub fn AttributesEncoder_AddAttributeId(this: *mut AttributesEncoder, id: i32);
}
extern "C" {
    #[doc = " Sets new attribute point ids (replacing the existing ones)."]
    #[link_name = "\u{1}_ZN5draco17AttributesEncoder15SetAttributeIdsERKSt6vectorIiSaIiEE"]
    pub fn AttributesEncoder_SetAttributeIds(
        this: *mut AttributesEncoder,
        point_attribute_ids: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17AttributesEncoder14GetAttributeIdEi"]
    pub fn AttributesEncoder_GetAttributeId(
        this: *const AttributesEncoder,
        i: ::std::os::raw::c_int,
    ) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17AttributesEncoder14num_attributesEv"]
    pub fn AttributesEncoder_num_attributes(this: *const AttributesEncoder) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17AttributesEncoder7encoderEv"]
    pub fn AttributesEncoder_encoder(this: *const AttributesEncoder) -> *mut PointCloudEncoder;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17AttributesEncoder27GetLocalIdForPointAttributeEi"]
    pub fn AttributesEncoder_GetLocalIdForPointAttribute(
        this: *const AttributesEncoder,
        point_attribute_id: i32,
    ) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17AttributesEncoderC2Ev"]
    pub fn AttributesEncoder_AttributesEncoder(this: *mut AttributesEncoder);
}
extern "C" {
    #[doc = " Constructs an attribute encoder associated with a given point attribute."]
    #[link_name = "\u{1}_ZN5draco17AttributesEncoderC2Ei"]
    pub fn AttributesEncoder_AttributesEncoder1(
        this: *mut AttributesEncoder,
        point_attrib_id: ::std::os::raw::c_int,
    );
}
impl Default for AttributesEncoder {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl AttributesEncoder {
    #[inline]
    pub unsafe fn AddAttributeId(&mut self, id: i32) {
        AttributesEncoder_AddAttributeId(self, id)
    }
    #[inline]
    pub unsafe fn SetAttributeIds(&mut self, point_attribute_ids: *const [u64; 3usize]) {
        AttributesEncoder_SetAttributeIds(self, point_attribute_ids)
    }
    #[inline]
    pub unsafe fn GetAttributeId(&self, i: ::std::os::raw::c_int) -> i32 {
        AttributesEncoder_GetAttributeId(self, i)
    }
    #[inline]
    pub unsafe fn num_attributes(&self) -> u32 {
        AttributesEncoder_num_attributes(self)
    }
    #[inline]
    pub unsafe fn encoder(&self) -> *mut PointCloudEncoder {
        AttributesEncoder_encoder(self)
    }
    #[inline]
    pub unsafe fn GetLocalIdForPointAttribute(&self, point_attribute_id: i32) -> i32 {
        AttributesEncoder_GetLocalIdForPointAttribute(self, point_attribute_id)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AttributesEncoder_AttributesEncoder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(point_attrib_id: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AttributesEncoder_AttributesEncoder1(__bindgen_tmp.as_mut_ptr(), point_attrib_id);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17AttributesEncoderD1Ev"]
    pub fn AttributesEncoder_AttributesEncoder_destructor(this: *mut AttributesEncoder);
}
extern "C" {
    #[doc = " Called after all attribute encoders are created. It can be used to perform\n any custom initialization, including setting up attribute dependencies.\n Note: no data should be encoded in this function, because the decoder may\n process encoders in a different order from the decoder."]
    #[link_name = "\u{1}_ZN5draco17AttributesEncoder4InitEPNS_17PointCloudEncoderEPKNS_10PointCloudE"]
    pub fn AttributesEncoder_Init(
        this: *mut ::std::os::raw::c_void,
        encoder: *mut PointCloudEncoder,
        pc: *const PointCloud,
    ) -> bool;
}
extern "C" {
    #[doc = " Encodes data needed by the target attribute decoder."]
    #[link_name = "\u{1}_ZN5draco17AttributesEncoder27EncodeAttributesEncoderDataEPNS_13EncoderBufferE"]
    pub fn AttributesEncoder_EncodeAttributesEncoderData(
        this: *mut ::std::os::raw::c_void,
        out_buffer: *mut EncoderBuffer,
    ) -> bool;
}
extern "C" {
    #[doc = " Encode attribute data to the target buffer."]
    #[link_name = "\u{1}_ZN5draco17AttributesEncoder16EncodeAttributesEPNS_13EncoderBufferE"]
    pub fn AttributesEncoder_EncodeAttributes(
        this: *mut ::std::os::raw::c_void,
        out_buffer: *mut EncoderBuffer,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the number of attributes that need to be encoded before the\n specified attribute is encoded.\n Note that the attribute is specified by its point attribute id."]
    #[link_name = "\u{1}_ZNK5draco17AttributesEncoder19NumParentAttributesEi"]
    pub fn AttributesEncoder_NumParentAttributes(
        this: *mut ::std::os::raw::c_void,
        arg1: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17AttributesEncoder20GetParentAttributeIdEii"]
    pub fn AttributesEncoder_GetParentAttributeId(
        this: *mut ::std::os::raw::c_void,
        arg1: i32,
        arg2: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Marks a given attribute as a parent of another attribute."]
    #[link_name = "\u{1}_ZN5draco17AttributesEncoder19MarkParentAttributeEi"]
    pub fn AttributesEncoder_MarkParentAttribute(
        this: *mut ::std::os::raw::c_void,
        arg1: i32,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns an attribute containing data processed by the attribute transform.\n (see TransformToPortableFormat() method). This data is guaranteed to be\n encoded losslessly and it can be safely used for predictors."]
    #[link_name = "\u{1}_ZN5draco17AttributesEncoder20GetPortableAttributeEi"]
    pub fn AttributesEncoder_GetPortableAttribute(
        this: *mut ::std::os::raw::c_void,
        arg1: i32,
    ) -> *const PointAttribute;
}
extern "C" {
    #[doc = " Transforms the input attribute data into a form that should be losslessly\n encoded (transform itself can be lossy)."]
    #[link_name = "\u{1}_ZN5draco17AttributesEncoder35TransformAttributesToPortableFormatEv"]
    pub fn AttributesEncoder_TransformAttributesToPortableFormat(
        this: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Encodes any data needed to revert the transform to portable format for each\n attribute (e.g. data needed for dequantization of quantized values)."]
    #[link_name = "\u{1}_ZN5draco17AttributesEncoder36EncodeDataNeededByPortableTransformsEPNS_13EncoderBufferE"]
    pub fn AttributesEncoder_EncodeDataNeededByPortableTransforms(
        this: *mut ::std::os::raw::c_void,
        out_buffer: *mut EncoderBuffer,
    ) -> bool;
}
#[repr(C)]
pub struct PointCloudEncoder__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Abstract base class for all point cloud and mesh encoders. It provides a\n basic functionality that's shared between different encoders."]
#[repr(C)]
#[derive(Debug)]
pub struct PointCloudEncoder {
    pub vtable_: *const PointCloudEncoder__bindgen_vtable,
    pub point_cloud_: *const PointCloud,
    pub attributes_encoders_: [u64; 3usize],
    #[doc = " Map between attribute id and encoder id."]
    pub attribute_to_encoder_map_: [u64; 3usize],
    #[doc = " Encoding order of individual attribute encoders (i.e., the order in which\n they are processed during encoding that may be different from the order\n in which they were created because of attribute dependencies."]
    pub attributes_encoder_ids_order_: [u64; 3usize],
    #[doc = " This buffer holds the final encoded data."]
    pub buffer_: *mut EncoderBuffer,
    pub options_: *const EncoderOptions,
    pub num_encoded_points_: usize,
}
extern "C" {
    #[doc = " Sets the point cloud that is going be encoded. Must be called before the\n Encode() method."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder13SetPointCloudERKNS_10PointCloudE"]
    pub fn PointCloudEncoder_SetPointCloud(this: *mut PointCloudEncoder, pc: *const PointCloud);
}
extern "C" {
    #[doc = " The main entry point that encodes provided point cloud."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder6EncodeERKNS_18EncoderOptionsBaseIiEEPNS_13EncoderBufferE"]
    pub fn PointCloudEncoder_Encode(
        this: *mut PointCloudEncoder,
        options: *const EncoderOptions,
        out_buffer: *mut EncoderBuffer,
    ) -> Status;
}
extern "C" {
    #[doc = " Returns the number of points that were encoded during the last Encode()\n function call. Valid only if \"store_number_of_encoded_points\" flag was set\n in the provided EncoderOptions."]
    #[link_name = "\u{1}_ZNK5draco17PointCloudEncoder18num_encoded_pointsEv"]
    pub fn PointCloudEncoder_num_encoded_points(this: *const PointCloudEncoder) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17PointCloudEncoder23num_attributes_encodersEv"]
    pub fn PointCloudEncoder_num_attributes_encoders(
        this: *const PointCloudEncoder,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder18attributes_encoderEi"]
    pub fn PointCloudEncoder_attributes_encoder(
        this: *mut PointCloudEncoder,
        i: ::std::os::raw::c_int,
    ) -> *mut AttributesEncoder;
}
extern "C" {
    #[doc = " Adds a new attribute encoder, returning its id."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder20AddAttributesEncoderESt10unique_ptrINS_17AttributesEncoderESt14default_deleteIS2_EE"]
    pub fn PointCloudEncoder_AddAttributesEncoder(
        this: *mut PointCloudEncoder,
        att_enc: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Marks one attribute as a parent of another attribute. Must be called after\n all attribute encoders are created (usually in the\n AttributeEncoder::Init() method)."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder19MarkParentAttributeEi"]
    pub fn PointCloudEncoder_MarkParentAttribute(
        this: *mut PointCloudEncoder,
        parent_att_id: i32,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns an attribute containing portable version of the attribute data that\n is guaranteed to be encoded losslessly. This attribute can be used safely\n as predictor for other attributes."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder20GetPortableAttributeEi"]
    pub fn PointCloudEncoder_GetPortableAttribute(
        this: *mut PointCloudEncoder,
        point_attribute_id: i32,
    ) -> *const PointAttribute;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder6bufferEv"]
    pub fn PointCloudEncoder_buffer(this: *mut PointCloudEncoder) -> *mut EncoderBuffer;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17PointCloudEncoder7optionsEv"]
    pub fn PointCloudEncoder_options(this: *const PointCloudEncoder) -> *const EncoderOptions;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17PointCloudEncoder11point_cloudEv"]
    pub fn PointCloudEncoder_point_cloud(this: *const PointCloudEncoder) -> *const PointCloud;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder22set_num_encoded_pointsEm"]
    pub fn PointCloudEncoder_set_num_encoded_points(
        this: *mut PointCloudEncoder,
        num_points: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoderC2Ev"]
    pub fn PointCloudEncoder_PointCloudEncoder(this: *mut PointCloudEncoder);
}
impl Default for PointCloudEncoder {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl PointCloudEncoder {
    #[inline]
    pub unsafe fn SetPointCloud(&mut self, pc: *const PointCloud) {
        PointCloudEncoder_SetPointCloud(self, pc)
    }
    #[inline]
    pub unsafe fn Encode(
        &mut self,
        options: *const EncoderOptions,
        out_buffer: *mut EncoderBuffer,
    ) -> Status {
        PointCloudEncoder_Encode(self, options, out_buffer)
    }
    #[inline]
    pub unsafe fn num_encoded_points(&self) -> usize {
        PointCloudEncoder_num_encoded_points(self)
    }
    #[inline]
    pub unsafe fn num_attributes_encoders(&self) -> ::std::os::raw::c_int {
        PointCloudEncoder_num_attributes_encoders(self)
    }
    #[inline]
    pub unsafe fn attributes_encoder(
        &mut self,
        i: ::std::os::raw::c_int,
    ) -> *mut AttributesEncoder {
        PointCloudEncoder_attributes_encoder(self, i)
    }
    #[inline]
    pub unsafe fn AddAttributesEncoder(&mut self, att_enc: u64) -> ::std::os::raw::c_int {
        PointCloudEncoder_AddAttributesEncoder(self, att_enc)
    }
    #[inline]
    pub unsafe fn MarkParentAttribute(&mut self, parent_att_id: i32) -> bool {
        PointCloudEncoder_MarkParentAttribute(self, parent_att_id)
    }
    #[inline]
    pub unsafe fn GetPortableAttribute(
        &mut self,
        point_attribute_id: i32,
    ) -> *const PointAttribute {
        PointCloudEncoder_GetPortableAttribute(self, point_attribute_id)
    }
    #[inline]
    pub unsafe fn buffer(&mut self) -> *mut EncoderBuffer {
        PointCloudEncoder_buffer(self)
    }
    #[inline]
    pub unsafe fn options(&self) -> *const EncoderOptions {
        PointCloudEncoder_options(self)
    }
    #[inline]
    pub unsafe fn point_cloud(&self) -> *const PointCloud {
        PointCloudEncoder_point_cloud(self)
    }
    #[inline]
    pub unsafe fn set_num_encoded_points(&mut self, num_points: usize) {
        PointCloudEncoder_set_num_encoded_points(self, num_points)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        PointCloudEncoder_PointCloudEncoder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoderD1Ev"]
    pub fn PointCloudEncoder_PointCloudEncoder_destructor(this: *mut PointCloudEncoder);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17PointCloudEncoder15GetGeometryTypeEv"]
    pub fn PointCloudEncoder_GetGeometryType(
        this: *mut ::std::os::raw::c_void,
    ) -> EncodedGeometryType;
}
extern "C" {
    #[doc = " Can be implemented by derived classes to perform any custom initialization\n of the encoder. Called in the Encode() method."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder17InitializeEncoderEv"]
    pub fn PointCloudEncoder_InitializeEncoder(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Should be used to encode any encoder-specific data."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder17EncodeEncoderDataEv"]
    pub fn PointCloudEncoder_EncodeEncoderData(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Encodes any global geometry data (such as the number of points)."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder18EncodeGeometryDataEv"]
    pub fn PointCloudEncoder_EncodeGeometryData(this: *mut ::std::os::raw::c_void) -> Status;
}
extern "C" {
    #[doc = " encode all attribute values. The attribute encoders are sorted to resolve\n any attribute dependencies and all the encoded data is stored into the\n |buffer_|.\n Returns false if the encoding failed."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder21EncodePointAttributesEv"]
    pub fn PointCloudEncoder_EncodePointAttributes(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Generate attribute encoders that are going to be used for encoding\n point attribute data. Calls GenerateAttributesEncoder() for every attribute\n of the encoded PointCloud."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder26GenerateAttributesEncodersEv"]
    pub fn PointCloudEncoder_GenerateAttributesEncoders(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Encodes any data that is necessary to recreate a given attribute encoder.\n Note: this is called in order in which the attribute encoders are going to\n be encoded."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder33EncodeAttributesEncoderIdentifierEi"]
    pub fn PointCloudEncoder_EncodeAttributesEncoderIdentifier(
        this: *mut ::std::os::raw::c_void,
        arg1: i32,
    ) -> bool;
}
extern "C" {
    #[doc = " Encodes all the attribute data using the created attribute encoders."]
    #[link_name = "\u{1}_ZN5draco17PointCloudEncoder19EncodeAllAttributesEv"]
    pub fn PointCloudEncoder_EncodeAllAttributes(this: *mut ::std::os::raw::c_void) -> bool;
}
#[repr(C)]
pub struct AttributesDecoderInterface__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Interface class for decoding one or more attributes that were encoded with a\n matching AttributesEncoder. It provides only the basic interface\n that is used by the PointCloudDecoder. The actual decoding must be\n implemented in derived classes using the DecodeAttributes() method."]
#[repr(C)]
#[derive(Debug)]
pub struct AttributesDecoderInterface {
    pub vtable_: *const AttributesDecoderInterface__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco26AttributesDecoderInterfaceC2Ev"]
    pub fn AttributesDecoderInterface_AttributesDecoderInterface(
        this: *mut AttributesDecoderInterface,
    );
}
impl Default for AttributesDecoderInterface {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl AttributesDecoderInterface {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        AttributesDecoderInterface_AttributesDecoderInterface(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco26AttributesDecoderInterfaceD1Ev"]
    pub fn AttributesDecoderInterface_AttributesDecoderInterface_destructor(
        this: *mut AttributesDecoderInterface,
    );
}
extern "C" {
    #[doc = " Returns an attribute containing data processed by the attribute transform.\n (see TransformToPortableFormat() method). This data is guaranteed to be\n same for encoder and decoder and it can be used by predictors."]
    #[link_name = "\u{1}_ZN5draco26AttributesDecoderInterface20GetPortableAttributeEi"]
    pub fn AttributesDecoderInterface_GetPortableAttribute(
        this: *mut ::std::os::raw::c_void,
        arg1: i32,
    ) -> *const PointAttribute;
}
#[repr(C)]
pub struct PointCloudDecoder__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Abstract base class for all point cloud and mesh decoders. It provides a\n basic functionality that is shared between different decoders."]
#[repr(C)]
#[derive(Debug)]
pub struct PointCloudDecoder {
    pub vtable_: *const PointCloudDecoder__bindgen_vtable,
    #[doc = " Point cloud that is being filled in by the decoder."]
    pub point_cloud_: *mut PointCloud,
    pub attributes_decoders_: [u64; 3usize],
    #[doc = " Map between attribute id and decoder id."]
    pub attribute_to_decoder_map_: [u64; 3usize],
    #[doc = " Input buffer holding the encoded data."]
    pub buffer_: *mut DecoderBuffer,
    #[doc = " Bit-stream version of the encoder that encoded the input data."]
    pub version_major_: u8,
    pub version_minor_: u8,
    pub options_: *const DecoderOptions,
}
extern "C" {
    #[doc = " Decodes a Draco header int other provided |out_header|.\n Returns false on error."]
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder12DecodeHeaderEPNS_13DecoderBufferEPNS_11DracoHeaderE"]
    pub fn PointCloudDecoder_DecodeHeader(
        buffer: *mut DecoderBuffer,
        out_header: *mut DracoHeader,
    ) -> Status;
}
extern "C" {
    #[doc = " The main entry point for point cloud decoding."]
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder6DecodeERKNS_12DracoOptionsINS_17GeometryAttribute4TypeEEEPNS_13DecoderBufferEPNS_10PointCloudE"]
    pub fn PointCloudDecoder_Decode(
        this: *mut PointCloudDecoder,
        options: *const DecoderOptions,
        in_buffer: *mut DecoderBuffer,
        out_point_cloud: *mut PointCloud,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder20SetAttributesDecoderEiSt10unique_ptrINS_26AttributesDecoderInterfaceESt14default_deleteIS2_EE"]
    pub fn PointCloudDecoder_SetAttributesDecoder(
        this: *mut PointCloudDecoder,
        att_decoder_id: ::std::os::raw::c_int,
        decoder: u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns an attribute containing decoded data in their portable form that\n is guaranteed to be the same for both encoder and decoder. I.e., it returns\n an attribute before it was transformed back into its final form which may\n be slightly different (non-portable) across platforms. For example, for\n attributes encoded with quantization, this method returns an attribute\n that contains the quantized values (before the dequantization step)."]
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder20GetPortableAttributeEi"]
    pub fn PointCloudDecoder_GetPortableAttribute(
        this: *mut PointCloudDecoder,
        point_attribute_id: i32,
    ) -> *const PointAttribute;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17PointCloudDecoder17bitstream_versionEv"]
    pub fn PointCloudDecoder_bitstream_version(this: *const PointCloudDecoder) -> u16;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder18attributes_decoderEi"]
    pub fn PointCloudDecoder_attributes_decoder(
        this: *mut PointCloudDecoder,
        dec_id: ::std::os::raw::c_int,
    ) -> *const AttributesDecoderInterface;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17PointCloudDecoder23num_attributes_decodersEv"]
    pub fn PointCloudDecoder_num_attributes_decoders(this: *const PointCloudDecoder) -> i32;
}
extern "C" {
    #[doc = " Get a mutable pointer to the decoded point cloud. This is intended to be\n used mostly by other decoder subsystems."]
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder11point_cloudEv"]
    pub fn PointCloudDecoder_point_cloud(this: *mut PointCloudDecoder) -> *mut PointCloud;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17PointCloudDecoder11point_cloudEv"]
    pub fn PointCloudDecoder_point_cloud1(this: *const PointCloudDecoder) -> *const PointCloud;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder6bufferEv"]
    pub fn PointCloudDecoder_buffer(this: *mut PointCloudDecoder) -> *mut DecoderBuffer;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17PointCloudDecoder7optionsEv"]
    pub fn PointCloudDecoder_options(this: *const PointCloudDecoder) -> *const DecoderOptions;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder14DecodeMetadataEv"]
    pub fn PointCloudDecoder_DecodeMetadata(this: *mut PointCloudDecoder) -> Status;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoderC2Ev"]
    pub fn PointCloudDecoder_PointCloudDecoder(this: *mut PointCloudDecoder);
}
impl Default for PointCloudDecoder {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl PointCloudDecoder {
    #[inline]
    pub unsafe fn DecodeHeader(buffer: *mut DecoderBuffer, out_header: *mut DracoHeader) -> Status {
        PointCloudDecoder_DecodeHeader(buffer, out_header)
    }
    #[inline]
    pub unsafe fn Decode(
        &mut self,
        options: *const DecoderOptions,
        in_buffer: *mut DecoderBuffer,
        out_point_cloud: *mut PointCloud,
    ) -> Status {
        PointCloudDecoder_Decode(self, options, in_buffer, out_point_cloud)
    }
    #[inline]
    pub unsafe fn SetAttributesDecoder(
        &mut self,
        att_decoder_id: ::std::os::raw::c_int,
        decoder: u64,
    ) -> bool {
        PointCloudDecoder_SetAttributesDecoder(self, att_decoder_id, decoder)
    }
    #[inline]
    pub unsafe fn GetPortableAttribute(
        &mut self,
        point_attribute_id: i32,
    ) -> *const PointAttribute {
        PointCloudDecoder_GetPortableAttribute(self, point_attribute_id)
    }
    #[inline]
    pub unsafe fn bitstream_version(&self) -> u16 {
        PointCloudDecoder_bitstream_version(self)
    }
    #[inline]
    pub unsafe fn attributes_decoder(
        &mut self,
        dec_id: ::std::os::raw::c_int,
    ) -> *const AttributesDecoderInterface {
        PointCloudDecoder_attributes_decoder(self, dec_id)
    }
    #[inline]
    pub unsafe fn num_attributes_decoders(&self) -> i32 {
        PointCloudDecoder_num_attributes_decoders(self)
    }
    #[inline]
    pub unsafe fn point_cloud(&mut self) -> *mut PointCloud {
        PointCloudDecoder_point_cloud(self)
    }
    #[inline]
    pub unsafe fn point_cloud1(&self) -> *const PointCloud {
        PointCloudDecoder_point_cloud1(self)
    }
    #[inline]
    pub unsafe fn buffer(&mut self) -> *mut DecoderBuffer {
        PointCloudDecoder_buffer(self)
    }
    #[inline]
    pub unsafe fn options(&self) -> *const DecoderOptions {
        PointCloudDecoder_options(self)
    }
    #[inline]
    pub unsafe fn DecodeMetadata(&mut self) -> Status {
        PointCloudDecoder_DecodeMetadata(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        PointCloudDecoder_PointCloudDecoder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoderD1Ev"]
    pub fn PointCloudDecoder_PointCloudDecoder_destructor(this: *mut PointCloudDecoder);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco17PointCloudDecoder15GetGeometryTypeEv"]
    pub fn PointCloudDecoder_GetGeometryType(
        this: *mut ::std::os::raw::c_void,
    ) -> EncodedGeometryType;
}
extern "C" {
    #[doc = " Can be implemented by derived classes to perform any custom initialization\n of the decoder. Called in the Decode() method."]
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder17InitializeDecoderEv"]
    pub fn PointCloudDecoder_InitializeDecoder(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder18DecodeGeometryDataEv"]
    pub fn PointCloudDecoder_DecodeGeometryData(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder21DecodePointAttributesEv"]
    pub fn PointCloudDecoder_DecodePointAttributes(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder19DecodeAllAttributesEv"]
    pub fn PointCloudDecoder_DecodeAllAttributes(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17PointCloudDecoder19OnAttributesDecodedEv"]
    pub fn PointCloudDecoder_OnAttributesDecoded(this: *mut ::std::os::raw::c_void) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EncodeResult {
    #[doc = " Indicates if encoding was successful"]
    pub success: bool,
    #[doc = " Size of the encoded data"]
    pub size: usize,
    #[doc = " Encoded data"]
    pub data: *const u8,
    #[doc = " Error message if encoding fails"]
    pub error_msg: *mut ::std::os::raw::c_char,
}
impl Default for EncodeResult {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DecodeResult {
    #[doc = " Indicates if decoding was successful"]
    pub success: bool,
    #[doc = " Number of points in the decoded data"]
    pub num_points: usize,
    #[doc = " Decoded coordinates"]
    pub coords: *mut f32,
    #[doc = " Decoded colors"]
    pub colors: *mut u8,
    #[doc = " Error message if decoding fails"]
    pub error_msg: *mut ::std::os::raw::c_char,
}
impl Default for DecodeResult {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DracoWrapper {
    pub _address: u8,
}
extern "C" {
    #[doc = " Function to encode points to Draco\n `coords` is an array of `num_points` * 3 floats, representing X, Y, Z for each point\n `colors` is an array of `num_points` * 3 uint8_t, representing R, G, B for each point"]
    #[link_name = "\u{1}_ZN13draco_wrapper12DracoWrapper22encode_points_to_dracoEPKfmPKh"]
    pub fn DracoWrapper_encode_points_to_draco(
        coords: *const f32,
        num_points: usize,
        colors: *const u8,
    ) -> *mut EncodeResult;
}
extern "C" {
    #[doc = " Function to decode Draco data into points and colors\n `encoded_data` is a pointer to the encoded buffer, and `encoded_size` is the buffer length"]
    #[link_name = "\u{1}_ZN13draco_wrapper12DracoWrapper17decode_draco_dataEPKhm"]
    pub fn DracoWrapper_decode_draco_data(
        encoded_data: *const u8,
        encoded_size: usize,
    ) -> *mut DecodeResult;
}
extern "C" {
    #[doc = " Function to free the encoded result"]
    #[link_name = "\u{1}_ZN13draco_wrapper12DracoWrapper18free_encode_resultEPNS_12EncodeResultE"]
    pub fn DracoWrapper_free_encode_result(result: *mut EncodeResult);
}
extern "C" {
    #[doc = " Function to free the decoded result"]
    #[link_name = "\u{1}_ZN13draco_wrapper12DracoWrapper18free_decode_resultEPNS_12DecodeResultE"]
    pub fn DracoWrapper_free_decode_result(result: *mut DecodeResult);
}
impl DracoWrapper {
    #[inline]
    pub unsafe fn encode_points_to_draco(
        coords: *const f32,
        num_points: usize,
        colors: *const u8,
    ) -> *mut EncodeResult {
        DracoWrapper_encode_points_to_draco(coords, num_points, colors)
    }
    #[inline]
    pub unsafe fn decode_draco_data(
        encoded_data: *const u8,
        encoded_size: usize,
    ) -> *mut DecodeResult {
        DracoWrapper_decode_draco_data(encoded_data, encoded_size)
    }
    #[inline]
    pub unsafe fn free_encode_result(result: *mut EncodeResult) {
        DracoWrapper_free_encode_result(result)
    }
    #[inline]
    pub unsafe fn free_decode_result(result: *mut DecodeResult) {
        DracoWrapper_free_decode_result(result)
    }
}
